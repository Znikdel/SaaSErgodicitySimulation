[General]
network = PretioWithLB
**.scalar-recording = true
**.vector-recording = true
cmdenv-interactive = true
**.cmdenv-log-level = off
# How to run frm command line?  opp_runall ./ErgodicityTest -u Cmdenv --sim-time-limit=1000s -f ../simulations/PretioWithLB/omnetpp.ini -c Scenario1-Type1-Short-Sessions
num-rngs = 2
ned-path=../../simulations;../../src;../../../inet4/src;../../../inet4/examples;../../../inet4/tutorials;../../../inet4/showcases;../../../neddemo;../../../queueinglib;../../../queueinglibext;../../../routing;../../../sockets;
**.cloudNetwork.ipv4Delayer.rng-0 = 1
**.cloudNetwork.ipv4Delayer.config = xmldoc("./../simulations/PretioWithLB/internetCloud.xml")

*.numClients = 1
*.numServers = 1
*.client[*].numApps = 3
*.client[*].app[*].typename="ErgodicityTestClient"
*.client[*].app[*].connectAddress = "server[0]"
#*.client[*].app[*].stopTime = 100000s
#*.client[*].app[0].numRequestsPerSession = int(exponential(2))

#*.client[*].app[*].requestLength = 1B*int(truncnormal(150,10))
#*.client[*].app[*].replyLength = 1B*int(truncnormal(350,20))
*.client[*].app[*].requestLength = 64B
#*.client[*].app[*].replyLength = 64B
#*.client[*].numPcapRecorders = 1
#*.client[*].pcapRecorder[0].pcapFile = "results/client0.pcap"
#**.crcMode = "computed"
#**.fcsMode = "computed"
*.client[*].app[0].thinkTime = int(exponential(0.5s))
#time gap between sessions
*.client[*].app[0].idleInterval = int(exponential(1s))


*.server[*].numVms = 1
*.server[*].vm[*].typename = "tryServer"
*.server[*].vm[*].replyDelay= int(exponential(10ms))
#*.server[*].vm[*].replyDelay= int(exponential(10ms))
*.server[*].ppp[*].ppp.queue.typename="DropTailQueue"
#*.server[*].OS_scheduler.S[*].serviceTime = exponential(2s)
*.server[*].OS_scheduler.Q[*].capacity = 10

**.ppp[*].ppp.queue.typename = "DropTailQueue" # in routers 
**.ppp[*].ppp.queue.packetCapacity = -1  # in routers
*.server[*].OS_scheduler.S[*].schedulerStatus = false
#*.server[*].OS_scheduler.Q[*].fifo = false

[Config forTest]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(10,14))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401#int(uniform(401,405))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
#int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[0].app[*].startTime = int(uniform(1s,1000s))
*.client[1].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(8000s,10000s))
*.client[6].app[*].startTime = int(uniform(9000s,10000s))
*.client[7].app[*].startTime = int(uniform(10000s,12000s))
*.client[8].app[*].startTime = int(uniform(11000s,12000s))
*.client[9].app[*].startTime = int(uniform(15000s,16000s))
*.client[0].app[*].stopTime = 36000s
*.client[1].app[*].stopTime = int(uniform(7000s,9000s))
*.client[2].app[*].stopTime = int(uniform(8000s,10000s))
*.client[3].app[*].stopTime = int(uniform(13000s,18000s))
*.client[4].app[*].stopTime = int(uniform(16000s,23000s))
*.client[5].app[*].stopTime = int(uniform(18000s,24000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(22000s,27000s))
*.client[8].app[*].stopTime = int(uniform(15000s,36000s))
*.client[9].app[*].stopTime = int(uniform(18000s,30000s))

**.server[*].vm[0].localPort = 401
#**.server[*].vm[1].localPort = 402
#**.server[*].vm[2].localPort = 403
#**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                     
#--------------------------------------------------------------------------------------------------

[Config Test-nr]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 3000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].thinkTime = exponential(10ms)  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession =7# 1+int(bernoulli(0.4))*int(binomial(5,0.27)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
            #                                                                           #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#--------------------------------------------------------------------------------------------------


[Config Scenario1-Type1-Short-Sessions-Poisson]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].thinkTime = exponential(10ms)  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(bernoulli(0.4))*int(binomial(5,0.27)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
            #                                                                           #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#----------------------------------------------------
[Config Scenario1-Type1-Short-Sessions-Bursty-non-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = false

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =300s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = false

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions, in bursty to give some time to other requests to get processed
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario1-Type1-Short-Sessions-Bursty-reliable-300]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = true

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =300s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = false

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario1-Type1-Short-Sessions-Bursty-reliable-500]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = true

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =500s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = false

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario1-Type2-App-Sessions-Bursty-reliable-300]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = true

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =300s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = false

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession =  1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario1-Type2-App-Sessions-Bursty-reliable-500]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = true

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =500s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = false

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession =  1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario1-Type2-App-Sessions-Bursty-reliable-random-burst]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = true

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =0s
*.client[*].app[*].randomBurst=true
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = false

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession =  1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario1-Type2-App-Sessions-Bursty-reliable-150]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = true

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =150s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = false

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession =  1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario1-Type2-Bursty-not-reliable-150]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = false

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =150s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = false

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession =  1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------

[Config Scenario1-Type2-Bursty-not-reliable-300]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = false

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =300s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession =  1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario1-Type2-Bursty-not-reliable-500]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = false

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =500s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = false

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession =  1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------

[Config Scenario1-Type2-Long-Sessions-Poisson-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different parallel clients on the workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401
*.client[0].app[*].burstyTraffic=false
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 100000
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].thinkTime = exponential(10ms)  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#--------------------------------------------


[Config Scenario1-Type2-Long-Sessions-Poisson-not-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # Here shows how much a burst is bigger than normal traffic e.g. *10
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 1000000
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].thinkTime = exponential(10ms)  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#--------------------------------------------

[Config Scenario2-Type1-Short-Sessions-Q-drops-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(8,10))
*.server[*].OS_scheduler.S[*].schedulerStatus = false

*.client[*].app[*].thinkTime = exponential(10ms)  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(bernoulli(0.4))*int(binomial(5,0.27)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
            #                                                                           #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#----------------------------------------------------

[Config Scenario2-Type1-Short-Sessions-Poisson-Q-drops-not-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].reliableProtocol = false
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(7,11))
*.server[*].OS_scheduler.S[*].schedulerStatus = false

*.client[*].app[*].thinkTime = exponential(10ms)  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(bernoulli(0.4))*int(binomial(5,0.27)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
            #                                                                           #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#----------------------------------------------------
[Config Scenario2-Type1-Short-Sessions-Bursty-Q-drops-reliable-300]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = true

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =300s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(7000,10000))
*.server[*].OS_scheduler.Q[*].fifo = false

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
#----------------------------------------------------
[Config Scenario2-Type1-Short-Sessions-Bursty-Q-drops-not-reliable-300]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = false

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =300s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(300,400))
*.server[*].OS_scheduler.Q[*].fifo = false

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------

[Config Scenario2-Type2-Long-Sessions-Q-drops-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401
*.client[*].app[*].reliableProtocol = true
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(400ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(7,13))
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario2-Type2-Long-Sessions-Q-drops-not-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(400ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(7,13))
*.client[*].app[*].reliableProtocol = false

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------


[Config Scenario2-Type2-Long-Sessions-Bursty-Q-drops-reliable-300]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = true

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =300s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(16000,20000))
*.server[*].OS_scheduler.Q[*].fifo = false

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario2-Type2-Long-Sessions-Bursty-Q-drops-not-reliable-300]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = false

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =300s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(300,350))
*.server[*].OS_scheduler.Q[*].fifo = false

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------

[Config Scenario3-Type1-Short-Sessions-No-Q-drops-reliable]
description = "Similar to sc1 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27)))#each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------

[Config Scenario3-Type1-Short-Sessions-No-Q-drops-not-reliable]
description = "Similar to sc1 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27)))#each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#-----------------------------------------
[Config Scenario3-Type1-Short-Sessions-No-Q-drops-not-reliable-RTOS]
description = "Similar to sc1 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(3,12))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = 401
*.client[*].app[*].RTOS = true

*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(400ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27)))#each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#-----------------------------------------

[Config Scenario3-Type2-Long-Sessions-No-Q-drops-reliable]
description = "Similar to sc1 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------

[Config Scenario3-Type2-Long-Sessions-No-Q-drops-not-reliable]
description = "Similar to sc1 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 100000000
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next



                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
#----------------------------------------------

[Config Scenario4-Type1-Short-Sessions-Q-drops-reliable]
description = "Similar to sc2 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
#----------------------------------------------

[Config Scenario4-Type1-Short-Sessions-Q-drops-not-reliable]
description = "Similar to sc2 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario4-Type2-Long-Sessions-Q-drops-reliable]
description = "Similar to sc2 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario4-Type2-Long-Sessions-Q-drops-reliable-1]
description = "Similar to sc2 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=1
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 40# int(uniform(2,8))*15
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                   
#-------------------------------------------------
[Config Scenario4-Type2-Long-Sessions-Q-drops-not-reliable]
description = "Similar to sc2 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------

[Config Scenario4-Type2-Long-Sessions-Q-drops-not-reliable-RTOS]
description = "Similar to sc2 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(3,9))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(400ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[*].app[*].RTOS = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------

[Config Scenario3-Type2-Load-balancer-No-Q-drops-reliable]
description = "Similar to sc3 but there is load balancing between 4 Vms on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = int(uniform(401,404))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 1000000# int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario3-Type2-Load-balancer-No-Q-drops-not-reliable]
description = "Similar to sc3 but there is load balancing between 4 Vms on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = int(uniform(401,404))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 1000000# int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario3-Type2-Long-Sessions-No-Q-drops-not-reliable-RTOS]
description = "Similar to sc3 but there is load balancing between 4 Vms on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = int(uniform(401,405))  # 
*.client[*].app[*].RTOS = true
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 1000000# int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------

[Config Scenario4-Type2-Long-Sessions-Load-Balancer-Q-drops-reliable]
description = "Similar to sc3 but there is load balancing between 4 Vms on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = int(uniform(401,404))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario3-Type2-Long-Sessions-Load-Balancer-No-Q-drops-not-reliable]
description = "Similar to sc3 but there is load balancing between 4 Vms on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = int(uniform(401,404))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 1000000 #int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario4-Type2-Long-Sessions-Load_Balancer-Q-drops-not-reliable]
description = "Similar to sc3 but there is load balancing between 4 Vms on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = int(uniform(401,404))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario5-Type2-Long-Sessions-no-Q-drops-reliable]
description = "Similar to sc5 but with varying workload on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(13,17))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[1*].numApps = 10 # number of different applications on each workload generator
*.client[0].numApps = 10
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401#int(uniform(401,405))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
#int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[0].app[*].startTime = 1s
*.client[1].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(8000s,10000s))
*.client[6].app[*].startTime = int(uniform(9000s,10000s))
*.client[7].app[*].startTime = int(uniform(10000s,12000s))
*.client[8].app[*].startTime = int(uniform(11000s,12000s))
*.client[9].app[*].startTime = int(uniform(15000s,16000s))
*.client[0].app[*].stopTime = 36000s
*.client[1].app[*].stopTime = int(uniform(27000s,36000s))
*.client[2].app[*].stopTime = int(uniform(18000s,19000s))
*.client[3].app[*].stopTime = int(uniform(13000s,23000s))
*.client[4].app[*].stopTime = int(uniform(16000s,23000s))
*.client[5].app[*].stopTime = int(uniform(18000s,24000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(22000s,27000s))
*.client[8].app[*].stopTime = int(uniform(15000s,36000s))
*.client[9].app[*].stopTime = int(uniform(18000s,30000s))

**.server[*].vm[0].localPort = 401
#**.server[*].vm[1].localPort = 402
#**.server[*].vm[2].localPort = 403
#**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario5-Type2-Long-Sessions-no-Q-drops-not-reliable]
description = "Similar to sc5 but with varying workload on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 15 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = 401#int(uniform(401,405))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
#int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[*].app[1*].startTime = int(uniform(10s,3000s))
*.client[*].app[1*].stopTime = int(uniform(4500s,20000s))

**.server[*].vm[0].localPort = 401
#**.server[*].vm[1].localPort = 402
#**.server[*].vm[2].localPort = 403
#**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario6-Type2-Long-Sessions-Q-drops-reliable]
description = "Similar to sc5 but with varying workload on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(3,9))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[*].numApps = 15 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = int(uniform(401,405))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(400ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[*].app[1*].startTime = int(uniform(10s,3000s))
*.client[*].app[1*].stopTime = int(uniform(3500s,30000s))

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------

