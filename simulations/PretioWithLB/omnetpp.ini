[General]
network = PretioWithLB
**.scalar-recording = true
**.vector-recording = true
cmdenv-interactive = true
**.cmdenv-log-level = off
# How to run frm command line?  opp_runall ./ErgodicityTest -u Cmdenv --sim-time-limit=1000s -f ../simulations/PretioWithLB/omnetpp.ini -c Scenario1-Type1-Short-Sessions
num-rngs = 2
ned-path=../../simulations;../../src;../../../inet4/src;../../../inet4/examples;../../../inet4/tutorials;../../../inet4/showcases;../../../neddemo;../../../queueinglib;../../../queueinglibext;../../../routing;../../../sockets;
**.cloudNetwork.ipv4Delayer.rng-0 = 1
**.cloudNetwork.ipv4Delayer.config = xmldoc("./../simulations/PretioWithLB/internetCloud.xml")

*.numClients = 1
*.numServers = 1
*.client[*].numApps = 1
*.client[*].app[*].typename="ClientTcpPoisson"
*.client[*].app[*].connectAddress = "server[0]"
#*.client[*].app[*].stopTime = 100000s
#*.client[*].app[0].numRequestsPerSession = int(exponential(2))

#*.client[*].app[*].requestLength = 1B*int(truncnormal(150,10))
#*.client[*].app[*].replyLength = 1B*int(truncnormal(350,20))
*.client[*].app[*].requestLength = 64B
*.client[*].app[*].replyLength = 128B
#*.client[*].numPcapRecorders = 1
#*.client[*].pcapRecorder[0].pcapFile = "results/client0.pcap"
#**.crcMode = "computed"
#**.fcsMode = "computed"
*.client[*].app[0].thinkTime = int(exponential(0.5s))
#time gap between sessions
*.client[*].app[0].idleInterval = int(exponential(1s))


*.server[*].numVms = 1
*.server[*].vm[*].typename = "tryServer"
*.server[*].vm[*].replyDelay= exponential(10ms)
#*.server[*].vm[*].replyDelay= int(exponential(10ms))
*.server[*].ppp[*].ppp.queue.typename="DropTailQueue"
*.server[*].OS_scheduler.S[*].serviceTime = exponential(2s)
*.server[*].OS_scheduler.Q[*].capacity = 10

**.ppp[*].ppp.queue.typename = "DropTailQueue" # in routers 
**.ppp[*].ppp.queue.packetCapacity = -1  # in routers



[Config Scenario1-Type1-Short-Sessions]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 1 # number of different applications on each workload generator
*.client[0].app[0].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[0].connectPort = 401
**.server[0].vm[0].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(10ms)
*.server[*].OS_scheduler.Q[*].capacity = 1000
*.server[*].OS_scheduler.S[*].schedulerStatus = false

*.client[*].app[0].thinkTime = exponential(10ms)  # makes each session longer
*.client[*].app[0].idleInterval = exponential(1ms) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(bernoulli(0.4))*int(binomial(5,0.27)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
            #                                                                           #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#----------------------------------------------------
[Config Scenario1-Type1-Short-Sessions-Bursty]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=1
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401

*.client[0].app[*].startBurst = 1s
*.client[0].app[*].burstLen =100s
*.client[0].app[*].burstyTraffic=true
#*.client[0].app[*].stopTime = int(uniform(1200s,1551s))

#*.client[1].app[*].startTime = int(uniform(1700s,1710s))
#*.client[1].app[*].stopOperationExtraTime = 1s
#*.client[1].app[*].stopTime = int(uniform(2900s,3200s))
#
#*.client[2].app[*].startTime = 3700s
#*.client[2].app[*].stopOperationExtraTime = 1s
#*.client[2].app[*].stopTime = int(uniform(4900s,5200s))
#
#*.client[3].app[*].startTime = 2000s
#*.client[3].app[*].stopOperationExtraTime = 1s
#*.client[3].app[*].stopTime = 2600s


*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(10ms)
*.server[*].OS_scheduler.Q[*].capacity = 1000
*.server[*].OS_scheduler.S[*].schedulerStatus = false

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(1ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial



[Config Scenario1-Type2-Long-Sessions]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 1 # number of different applications on each workload generator
*.client[0].app[0].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[0].connectPort = 401
**.server[0].vm[0].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(100ms)
*.server[*].OS_scheduler.Q[*].capacity = 1000

*.client[*].app[0].thinkTime = int(exponential(1s))  # makes each session longer
*.client[*].app[0].idleInterval = exponential(10ms) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial




#--------------------------------------------


[Config Scenario1-Type2-Long-Sessions-Bursty]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=1
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 1 # number of different applications on each workload generator
*.client[0].app[0].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[0].connectPort = 401
**.server[0].vm[0].localPort = 401

*.client[0].app[*].startBurst = 1s
*.client[0].app[*].burstLen =100s
*.client[0].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(100ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000

*.client[*].app[0].thinkTime = int(exponential(1s))  # makes each session longer
*.client[*].app[0].idleInterval = exponential(10ms) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial




#--------------------------------------------

[Config Scenario2-Type1-Short-Sessions-Q-drops-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=1
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(10ms)
*.server[*].OS_scheduler.Q[*].capacity = 98
*.server[*].OS_scheduler.S[*].schedulerStatus = false

*.client[*].app[*].thinkTime = exponential(10ms)  # makes each session longer
*.client[*].app[*].idleInterval = exponential(1ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(bernoulli(0.4))*int(binomial(5,0.27)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
            #                                                                           #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#----------------------------------------------------

[Config Scenario2-Type1-Short-Sessions-Q-drops-not-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=1
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].reliableProtocol = false
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(10ms)
*.server[*].OS_scheduler.Q[*].capacity = 98
*.server[*].OS_scheduler.S[*].schedulerStatus = false

*.client[*].app[*].thinkTime = exponential(10ms)  # makes each session longer
*.client[*].app[*].idleInterval = exponential(1ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(bernoulli(0.4))*int(binomial(5,0.27)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
            #                                                                           #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#----------------------------------------------------

[Config Scenario2-Type2-Long-Sessions-Q-drops-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=1
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(100ms)
*.server[*].OS_scheduler.Q[*].capacity = 200

*.client[*].app[*].thinkTime = int(exponential(1s))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(10ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario2-Type2-Long-Sessions-Q-drops-not-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=1
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(100ms)
*.server[*].OS_scheduler.Q[*].capacity = 200
*.server[*].OS_scheduler.S[*].schedulerStatus = false

*.client[*].app[*].thinkTime = int(exponential(1s))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(10ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------








[Config Poisson-workload-1-scenario1-scenario1]
description = "Scenario 1 - 10 runs"
*.numClients = 10  #clients contain "app" module which is a workload generator based on type of the application 
*.numServers = 10  # Physical Cloud Nodes
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 1 # number of different applications on each workload generator
*.client[*].app[*].typename="ClientTcpPoisson"  #Type of workload generator
*.client[0].app[0].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[0].connectPort = 401
*.client[1].app[0].connectAddress = "server[1]"  
*.client[1].app[0].connectPort = 402
*.client[2].app[0].connectAddress = "server[2]"  
*.client[2].app[0].connectPort = 403
*.client[3].app[0].connectAddress = "server[3]"  
*.client[3].app[0].connectPort = 404
*.client[4].app[0].connectAddress = "server[4]"  
*.client[4].app[0].connectPort = 405
*.client[5].app[0].connectAddress = "server[5]"  
*.client[5].app[0].connectPort = 406
*.client[6].app[0].connectAddress = "server[6]"  
*.client[6].app[0].connectPort = 407
*.client[7].app[0].connectAddress = "server[7]"  
*.client[7].app[0].connectPort = 408
*.client[8].app[0].connectAddress = "server[8]"  
*.client[8].app[0].connectPort = 409
*.client[9].app[0].connectAddress = "server[9]"  
*.client[9].app[0].connectPort = 410
**.server[0].vm[0].localPort = 401
**.server[1].vm[0].localPort = 402
**.server[2].vm[0].localPort = 403
**.server[3].vm[0].localPort = 404
**.server[4].vm[0].localPort = 405
**.server[5].vm[0].localPort = 406
**.server[6].vm[0].localPort = 407
**.server[7].vm[0].localPort = 408
**.server[8].vm[0].localPort = 409
**.server[9].vm[0].localPort = 410

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(10ms)
*.server[*].OS_scheduler.Q[*].capacity = 1000

*.client[*].app[0].thinkTime = int(exponential(10ms))  # makes each session longer
*.client[*].app[0].idleInterval = exponential(1ms) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(bernoulli(0.4))*int(binomial(5,0.27)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

[Config Poisson-workload-1-scenario2]
description = "Scenario 1 - 10 runs"
*.numClients = 10  #clients contain "app" module which is a workload generator based on type of the application 
*.numServers = 10  # Physical Cloud Nodes
*.server[*].numVms = 10
*.client[0].app[0].connectPort = 401
*.client[1].app[0].connectPort = 402
*.client[2].app[0].connectPort = 403
*.client[3].app[0].connectPort = 404
*.client[4].app[0].connectPort = 405
*.client[5].app[0].connectPort = 406
*.client[6].app[0].connectPort = 407
*.client[7].app[0].connectPort = 408
*.client[8].app[0].connectPort = 409
*.client[9].app[0].connectPort = 410
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
**.server[0].vm[4].localPort = 405
**.server[0].vm[5].localPort = 406
**.server[0].vm[6].localPort = 407
**.server[0].vm[7].localPort = 408
**.server[0].vm[8].localPort = 409
**.server[0].vm[9].localPort = 410

*.server[*].OS_scheduler.S[*].serviceTime = exponential(2s)
*.server[*].OS_scheduler.Q[*].capacity = 10

*.client[*].app[0].thinkTime = int(exponential(10ms))  # makes each session longer
*.client[*].app[0].idleInterval = exponential(1ms) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(bernoulli(0.4))*int(binomial(5,0.27)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
[Config Type2-requests]
description = "The requests are expected within each session follow a binomial distribution"
*.numClients = 1
*.client[0].app[0].idleInterval = int(exponential(0.04s)) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(bernoulli(0.4))*int(binomial(5,0.27))
*.client[*].app[0].thinkTime = int(exponential(5s))  # makes each session longer

[Config Pretio-wl-4-webserver]
description = "It simulates pretio workload with one dedicated server (VM) - 10 parallel runs"
*.numClients = 10
*.numServers = 1
*.server[*].numVms = 4
*.client[*].app[0].connectPort = int(uniform(400,405))
# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 404
**.server[0].vm[1].localPort = 401
**.server[0].vm[2].localPort = 402
**.server[0].vm[3].localPort = 403

*.client[*].app[0].idleInterval = exponential(0.04s) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(bernoulli(0.4))*int(binomial(5,0.27)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = int(exponential(5s))  # times between two requests, makes each session longer

[Config Pretio-wl-4-webserver-for-test-without-Qdrop]
description = "It simulates pretio workload with one dedicated server"
*.numClients = 10
*.numServers = 1
*.server[*].numVms = 4
*.client[*].app[0].connectPort = int(uniform(399,405))
# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
*.server[*].OS_scheduler.S[*].serviceTime = exponential(2s)
*.server[*].OS_scheduler.Q[*].capacity = 10

*.client[*].app[0].idleInterval = exponential(0.04s) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(binomial(15,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = exponential(0.25s)  # times between two requests, makes each session longer

[Config one-req-4-webserver-for-test-without-Qdrop]
description = "It simulates pretio workload with one dedicated server"
*.numClients = 10
*.numServers = 1
*.server[*].numVms = 4
*.client[*].app[0].connectPort = int(uniform(399,405))
# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
*.server[*].OS_scheduler.S[*].serviceTime = exponential(1s)
*.server[*].OS_scheduler.Q[*].capacity = 10

*.client[*].app[0].idleInterval = exponential(0.04s) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1  #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = exponential(0.25s)  # times between two requests, makes each session longer


[Config Pretio-wl-4-webserver-for-test-with-Q-drops]
description = "It simulates pretio workload on a shared server with q drops activated"
*.numClients = 10
*.numServers = 1
*.server[*].numVms = 4
*.client[*].app[0].connectPort = int(uniform(399,405))
# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
*.server[*].OS_scheduler.S[*].serviceTime = exponential(2s)
*.server[*].OS_scheduler.Q[*].capacity = 5
*.server[*].OS_scheduler.S[*].schedulerStatus = false


*.client[*].app[0].idleInterval = exponential(0.04s) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(binomial(15,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = exponential(0.25s)  # times between two requests, makes each session longer

[Config Pretio-wl-4-webserver-for-test-without-Q-drops2]
description = "It simulates pretio workload with one dedicated server"
*.numClients = 10
*.numServers = 1
*.server[*].numVms = 4
*.client[*].app[0].connectPort = int(uniform(399,405))
# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
*.server[*].OS_scheduler.S[*].serviceTime = exponential(2s)
*.server[*].OS_scheduler.Q[*].capacity = 20

*.client[*].app[0].idleInterval = exponential(0.4s) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(binomial(15,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = exponential(0.25s)  # times between two requests, makes each session longer

[Config Pretio-wl-10-parallel-run-without-app-level-Qdrops-dedicated-server]
description = "It simulates pretio workload on dedicated servers (VM)"
*.numClients = 10
*.numServers = 1
*.server[*].numVms = 10
*.client[0].app[0].connectPort = 401
*.client[1].app[0].connectPort = 402
*.client[2].app[0].connectPort = 403
*.client[3].app[0].connectPort = 404
*.client[4].app[0].connectPort = 405
*.client[5].app[0].connectPort = 406
*.client[6].app[0].connectPort = 407
*.client[7].app[0].connectPort = 408
*.client[8].app[0].connectPort = 409
*.client[9].app[0].connectPort = 410
# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
**.server[0].vm[4].localPort = 405
**.server[0].vm[5].localPort = 406
**.server[0].vm[6].localPort = 407
**.server[0].vm[7].localPort = 408
**.server[0].vm[8].localPort = 409
**.server[0].vm[9].localPort = 410

*.server[*].OS_scheduler.S[*].serviceTime = exponential(2s)
*.server[*].OS_scheduler.Q[*].capacity = 20

*.client[*].app[0].idleInterval = exponential(0.4s) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(binomial(15,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = exponential(0.25s)  # times between two requests, makes each session longer


[Config Pretio-wl-10-parallel-run-without-app-level-Q-drops-shared-server]
description = "It simulates pretio workload on cloud shared servers, we don't know about the load on those servers"
*.numClients = 40
*.numServers = 1
*.server[*].numVms = 10
*.client[*].app[0].connectPort = int(uniform(400,411))

# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
**.server[0].vm[4].localPort = 405
**.server[0].vm[5].localPort = 406
**.server[0].vm[6].localPort = 407
**.server[0].vm[7].localPort = 408
**.server[0].vm[8].localPort = 409
**.server[0].vm[9].localPort = 410

*.server[*].OS_scheduler.S[*].serviceTime = exponential(2s)
*.server[*].OS_scheduler.Q[*].capacity = 20

*.client[*].app[0].idleInterval = exponential(0.4s) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(binomial(15,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = exponential(0.25s)  # times between two requests, makes each session longer

[Config SCHEDULING-EFFECT-Pretio-wl-20run-10VMs-Scheduling-on-QDrop-off]
description = "It simulates pretio workload on cloud shared servers between 10 VMs,no Q drops, No different loads"
*.numClients = 20
*.numServers = 1
*.server[*].numVms = 6
#*.client[*].app[*].connectPort = int(uniform(401,405))
*.client[0].app[0].connectPort = 401
*.client[1].app[0].connectPort = 402
*.client[2].app[0].connectPort = 402
*.client[3].app[0].connectPort = 403
*.client[4].app[0].connectPort = 403
*.client[5].app[0].connectPort = 403
*.client[6].app[0].connectPort = 404
*.client[7].app[0].connectPort = 404
*.client[8].app[0].connectPort = 404
*.client[9].app[0].connectPort = 404
*.client[10].app[0].connectPort = 405
*.client[11].app[0].connectPort = 405
*.client[12].app[0].connectPort = 405
*.client[13].app[0].connectPort = 405
*.client[14].app[0].connectPort = 405
*.client[15].app[0].connectPort = 406
*.client[16].app[0].connectPort = 406
*.client[17].app[0].connectPort = 406
*.client[18].app[0].connectPort = 406
*.client[19].app[0].connectPort = 406
*.client[20].app[0].connectPort = 406


# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
**.server[0].vm[4].localPort = 405
**.server[0].vm[5].localPort = 406
#**.server[0].vm[6].localPort = 407
#**.server[0].vm[7].localPort = 408
#**.server[0].vm[8].localPort = 409
#**.server[0].vm[9].localPort = 410

*.server[*].OS_scheduler.S[*].serviceTime = exponential(0.09s) #in milliseconds actually 
*.server[*].OS_scheduler.S[*].sleepTime = exponential(0.8s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(0.2s)
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = 20

*.client[*].app[0].idleInterval = exponential(0.001s) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(binomial(6,0.6)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = exponential(0.001s)  # times between two requests, makes each session longer


[Config SCHEDULING-EFFECT-Pretio-wl-10-VMs-Scheduling-is-off-QDrop-off]
description = "It simulates pretio workload on cloud shared servers between 10 VMs,no Q drops, No different loads"
*.numClients = 10
*.numServers = 1
*.server[*].numVms = 10
*.client[0].app[0].connectPort = 401
*.client[1].app[0].connectPort = 402
*.client[2].app[0].connectPort = 403
*.client[3].app[0].connectPort = 404
*.client[4].app[0].connectPort = 405
*.client[5].app[0].connectPort = 406
*.client[6].app[0].connectPort = 407
*.client[7].app[0].connectPort = 408
*.client[8].app[0].connectPort = 409
*.client[9].app[0].connectPort = 410
#*.client[10].app[0].connectPort = 401
#*.client[11].app[0].connectPort = 402
#*.client[12].app[0].connectPort = 403
#*.client[13].app[0].connectPort = 404
#*.client[14].app[0].connectPort = 405
#*.client[15].app[0].connectPort = 406
#*.client[16].app[0].connectPort = 407
#*.client[17].app[0].connectPort = 408
#*.client[18].app[0].connectPort = 409
#*.client[19].app[0].connectPort = 410
# Another choice of server app (it does the same as Tcp

# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
**.server[0].vm[4].localPort = 405
**.server[0].vm[5].localPort = 406
**.server[0].vm[6].localPort = 407
**.server[0].vm[7].localPort = 408
**.server[0].vm[8].localPort = 409
**.server[0].vm[9].localPort = 410

*.server[*].OS_scheduler.S[*].serviceTime = exponential(0.09s) 
*.server[*].OS_scheduler.S[*].sleepTime = exponential(0.8s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(0.2s)
*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.Q[*].capacity = 20

*.client[*].app[0].idleInterval = exponential(0.001s) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = exponential(0.001s)  # times between two requests, makes each session longer

[Config SCHEDULING-EFFECT-Pretio-wl-10-runs-Scheduling-is-off-QDrop-is-on]
description = "It simulates pretio workload on cloud shared servers between 10 VMs,no Q drops, No different loads"
*.numClients = 10
*.numServers = 1
*.server[*].numVms = 5
*.client[0].app[0].connectPort = 401
*.client[1].app[0].connectPort = 402
*.client[2].app[0].connectPort = 403
*.client[3].app[0].connectPort = 404
*.client[4].app[0].connectPort = 405
*.client[5].app[0].connectPort = 401
*.client[6].app[0].connectPort = 402
*.client[7].app[0].connectPort = 403
*.client[8].app[0].connectPort = 404
*.client[9].app[0].connectPort = 405
#*.client[10].app[0].connectPort = 401
#*.client[11].app[0].connectPort = 402
#*.client[12].app[0].connectPort = 403
#*.client[13].app[0].connectPort = 404
#*.client[14].app[0].connectPort = 405
#*.client[15].app[0].connectPort = 406
#*.client[16].app[0].connectPort = 407
#*.client[17].app[0].connectPort = 408
#*.client[18].app[0].connectPort = 409
#*.client[19].app[0].connectPort = 410
# Another choice of server app (it does the same as Tcp

# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
**.server[0].vm[4].localPort = 405
**.server[0].vm[5].localPort = 406
**.server[0].vm[6].localPort = 407
**.server[0].vm[7].localPort = 408
**.server[0].vm[8].localPort = 409
**.server[0].vm[9].localPort = 410


*.server[*].OS_scheduler.S[*].serviceTime = exponential(0.09s) 
*.server[*].OS_scheduler.S[*].sleepTime = exponential(0.8s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(0.2s)
*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.Q[*].capacity = 3

*.client[*].app[0].idleInterval = exponential(0.001s) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = exponential(0.001s)  # times between two requests, makes each session longer

[Config SCHEDULING-EFFECT-Pretio-wl-10-runs-Scheduling-is-on-QDrop-is-on]
description = "It simulates pretio workload on cloud shared servers between 10 VMs,no Q drops, No different loads"
*.numClients = 10
*.numServers = 1
*.server[*].numVms = 5
*.client[0].app[0].connectPort = 401
*.client[1].app[0].connectPort = 402
*.client[2].app[0].connectPort = 403
*.client[3].app[0].connectPort = 404
*.client[4].app[0].connectPort = 405
*.client[5].app[0].connectPort = 401
*.client[6].app[0].connectPort = 402
*.client[7].app[0].connectPort = 403
*.client[8].app[0].connectPort = 404
*.client[9].app[0].connectPort = 405
#*.client[10].app[0].connectPort = 401
#*.client[11].app[0].connectPort = 402
#*.client[12].app[0].connectPort = 403
#*.client[13].app[0].connectPort = 404
#*.client[14].app[0].connectPort = 405
#*.client[15].app[0].connectPort = 406
#*.client[16].app[0].connectPort = 407
#*.client[17].app[0].connectPort = 408
#*.client[18].app[0].connectPort = 409
#*.client[19].app[0].connectPort = 410
# Another choice of server app (it does the same as Tcp

# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
**.server[0].vm[4].localPort = 405
**.server[0].vm[5].localPort = 406
**.server[0].vm[6].localPort = 407
**.server[0].vm[7].localPort = 408
**.server[0].vm[8].localPort = 409
**.server[0].vm[9].localPort = 410


*.server[*].OS_scheduler.S[*].serviceTime = exponential(0.09s) 
*.server[*].OS_scheduler.S[*].sleepTime = exponential(0.8s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(0.2s)
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = 3

*.client[*].app[0].idleInterval = exponential(0.001s) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = exponential(0.001s)  # times between two requests, makes each session longer


[Config SCHEDULING-EFFECT-Pretio-wl-10-runs-Scheduling-is-on-QDrop-is-off]
description = "It simulates pretio workload on cloud shared servers between 10 VMs,no Q drops, No different loads"
*.numClients = 10
*.numServers = 1
*.server[*].numVms = 5
*.client[0].app[0].connectPort = 401
*.client[1].app[0].connectPort = 402
*.client[2].app[0].connectPort = 403
*.client[3].app[0].connectPort = 404
*.client[4].app[0].connectPort = 405
*.client[5].app[0].connectPort = 401
*.client[6].app[0].connectPort = 402
*.client[7].app[0].connectPort = 403
*.client[8].app[0].connectPort = 404
*.client[9].app[0].connectPort = 405
#*.client[10].app[0].connectPort = 401
#*.client[11].app[0].connectPort = 402
#*.client[12].app[0].connectPort = 403
#*.client[13].app[0].connectPort = 404
#*.client[14].app[0].connectPort = 405
#*.client[15].app[0].connectPort = 406
#*.client[16].app[0].connectPort = 407
#*.client[17].app[0].connectPort = 408
#*.client[18].app[0].connectPort = 409
#*.client[19].app[0].connectPort = 410
# Another choice of server app (it does the same as Tcp

# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
**.server[0].vm[4].localPort = 405
**.server[0].vm[5].localPort = 406
**.server[0].vm[6].localPort = 407
**.server[0].vm[7].localPort = 408
**.server[0].vm[8].localPort = 409
**.server[0].vm[9].localPort = 410


*.server[*].OS_scheduler.S[*].serviceTime = exponential(0.09s) 
*.server[*].OS_scheduler.S[*].sleepTime = exponential(0.8s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(0.2s)
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = 10

*.client[*].app[0].idleInterval = exponential(0.001s) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = exponential(0.001s)  # times between two requests, makes each session longer


[Config SCHEDULING-EFFECT-Pretio-wl-4-servers-variable-VMs-Scheduling-is-on-QDrop-off]
description = "It simulates pretio workload on cloud shared servers between 10 VMs,no Q drops, No different loads"
*.numClients = 100
*.numServers = 4
*.server[0].numVms = 1
*.server[1].numVms = 4
*.server[2].numVms = 10
*.server[3].numVms = 20

*.client[0].app[0].connectAddress = "server[0]"
*.client[1].app[0].connectAddress = "server[0]"
*.client[2].app[0].connectAddress = "server[0]"
*.client[3].app[0].connectAddress = "server[0]"
*.client[4].app[0].connectAddress = "server[0]"
*.client[5].app[0].connectAddress = "server[0]"
*.client[6].app[0].connectAddress = "server[0]"
*.client[7].app[0].connectAddress = "server[0]"
*.client[8].app[0].connectAddress = "server[0]"
*.client[9].app[0].connectAddress = "server[0]"

*.client[1*].app[*].connectAddress = "server[1]"

*.client[2*].app[*].connectAddress = "server[2]"
*.client[3*].app[*].connectAddress = "server[2]"
*.client[4*].app[*].connectAddress = "server[2]"
*.client[5*].app[*].connectAddress = "server[2]"

*.client[6*].app[*].connectAddress = "server[3]"
*.client[7*].app[*].connectAddress = "server[3]"
*.client[8*].app[*].connectAddress = "server[3]"
*.client[9*].app[*].connectAddress = "server[3]"



# First server has one VM and that VM has 10 containers
*.server[0].vm[0].localPort = 401
*.client[0].app[0].connectPort = 401
*.client[1].app[0].connectPort = 401
*.client[2].app[0].connectPort = 401
*.client[3].app[0].connectPort = 401
*.client[4].app[0].connectPort = 401
*.client[5].app[0].connectPort = 401
*.client[6].app[0].connectPort = 401
*.client[7].app[0].connectPort = 401
*.client[8].app[0].connectPort = 401
*.client[9].app[0].connectPort = 401

*.server[0].OS_scheduler.S[*].serviceTime = exponential(0.3s) 
*.server[0].OS_scheduler.S[*].sleepTime = 9s
*.server[0].OS_scheduler.S[*].scheduleShare = 1s
*.server[0].OS_scheduler.S[*].schedulerStatus = false
*.server[0].OS_scheduler.Q[*].capacity = 20

# second server has 5 VMs and each VM has different number of containers.

**.server[1].vm[0].localPort = 501
**.server[1].vm[1].localPort = 502
**.server[1].vm[2].localPort = 503
**.server[1].vm[3].localPort = 504
*.client[1*].app[*].connectPort = int(uniform(500,505))


*.server[1].OS_scheduler.S[*].serviceTime = exponential(0.3s) 
*.server[1].OS_scheduler.S[*].sleepTime = 9s
*.server[1].OS_scheduler.S[*].scheduleShare = 3s
*.server[1].OS_scheduler.S[*].schedulerStatus = true
*.server[1].OS_scheduler.Q[*].capacity = 20


# Third server has 10 VMs
*.server[2].vm[0].localPort = 601
*.server[2].vm[1].localPort = 602
*.server[2].vm[2].localPort = 603
*.server[2].vm[3].localPort = 604
*.server[2].vm[4].localPort = 605
*.server[2].vm[5].localPort = 606
*.server[2].vm[6].localPort = 607
*.server[2].vm[7].localPort = 608
*.server[2].vm[8].localPort = 609
*.server[2].vm[9].localPort = 610
*.client[2*].app[*].connectPort = int(uniform(600,611))
*.client[3*].app[*].connectPort = int(uniform(600,611))
*.client[4*].app[*].connectPort = int(uniform(600,611))
*.client[5*].app[*].connectPort = int(uniform(600,611))

*.server[2].OS_scheduler.S[*].serviceTime = exponential(0.3s) 
*.server[2].OS_scheduler.S[*].sleepTime = 27s
*.server[2].OS_scheduler.S[*].scheduleShare = 3s
*.server[2].OS_scheduler.S[*].schedulerStatus = true
*.server[2].OS_scheduler.Q[*].capacity = 20


#server 4 has 20 VMs
*.server[3].vm[0].localPort = 701
*.server[3].vm[1].localPort = 702
*.server[3].vm[2].localPort = 703
*.server[3].vm[3].localPort = 704
*.server[3].vm[4].localPort = 705
*.server[3].vm[5].localPort = 706
*.server[3].vm[6].localPort = 707
*.server[3].vm[7].localPort = 708
*.server[3].vm[8].localPort = 709
*.server[3].vm[9].localPort = 710
*.server[3].vm[10].localPort = 711
*.server[3].vm[11].localPort = 712
*.server[3].vm[12].localPort = 713
*.server[3].vm[13].localPort = 714
*.server[3].vm[14].localPort = 715
*.server[3].vm[15].localPort = 716
*.server[3].vm[16].localPort = 717
*.server[3].vm[17].localPort = 718
*.server[3].vm[18].localPort = 719
*.server[3].vm[19].localPort = 720
*.client[6*].app[*].connectPort = int(uniform(700,721))
*.client[7*].app[*].connectPort = int(uniform(700,721))
*.client[8*].app[*].connectPort = int(uniform(700,721))
*.client[9*].app[*].connectPort = int(uniform(700,721))


*.server[3].OS_scheduler.S[*].serviceTime = exponential(0.3s) 
*.server[3].OS_scheduler.S[*].sleepTime = 57s
*.server[3].OS_scheduler.S[*].scheduleShare = 3s
*.server[3].OS_scheduler.S[*].schedulerStatus = true
*.server[3].OS_scheduler.Q[*].capacity = 20


*.client[*].app[0].idleInterval = exponential(0.001s) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(binomial(6,0.6)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = exponential(0.001s)  # times between two requests, makes each session longer




[Config SCHEDULING-EFFECT-Pretio-wl-4-servers-variable-VMs-Scheduling-is-on-QDrop-on]
description = "It simulates pretio workload on cloud shared servers between 10 VMs,no Q drops, No different loads"
*.numClients = 100
*.numServers = 4
*.server[0].numVms = 1
*.server[1].numVms = 4
*.server[2].numVms = 10
*.server[3].numVms = 20

*.client[0].app[0].connectAddress = "server[0]"
*.client[1].app[0].connectAddress = "server[0]"
*.client[2].app[0].connectAddress = "server[0]"
*.client[3].app[0].connectAddress = "server[0]"
*.client[4].app[0].connectAddress = "server[0]"
*.client[5].app[0].connectAddress = "server[0]"
*.client[6].app[0].connectAddress = "server[0]"
*.client[7].app[0].connectAddress = "server[0]"
*.client[8].app[0].connectAddress = "server[0]"
*.client[9].app[0].connectAddress = "server[0]"

*.client[1*].app[*].connectAddress = "server[1]"

*.client[2*].app[*].connectAddress = "server[2]"
*.client[3*].app[*].connectAddress = "server[2]"
*.client[4*].app[*].connectAddress = "server[2]"
*.client[5*].app[*].connectAddress = "server[2]"

*.client[6*].app[*].connectAddress = "server[3]"
*.client[7*].app[*].connectAddress = "server[3]"
*.client[8*].app[*].connectAddress = "server[3]"
*.client[9*].app[*].connectAddress = "server[3]"



# First server has one VM and that VM has 10 containers
*.server[0].vm[0].localPort = 401
*.client[0].app[0].connectPort = 401
*.client[1].app[0].connectPort = 401
*.client[2].app[0].connectPort = 401
*.client[3].app[0].connectPort = 401
*.client[4].app[0].connectPort = 401
*.client[5].app[0].connectPort = 401
*.client[6].app[0].connectPort = 401
*.client[7].app[0].connectPort = 401
*.client[8].app[0].connectPort = 401
*.client[9].app[0].connectPort = 401

*.server[0].OS_scheduler.S[*].serviceTime = exponential(3s) 
*.server[0].OS_scheduler.S[*].sleepTime = 9s
*.server[0].OS_scheduler.S[*].scheduleShare = 1s
*.server[0].OS_scheduler.S[*].schedulerStatus = false
*.server[0].OS_scheduler.Q[*].capacity = 18

# second server has 5 VMs and each VM has different number of containers.

**.server[1].vm[0].localPort = 501
**.server[1].vm[1].localPort = 502
**.server[1].vm[2].localPort = 503
**.server[1].vm[3].localPort = 504
*.client[1*].app[*].connectPort = int(uniform(500,505))


*.server[1].OS_scheduler.S[*].serviceTime = exponential(3s) 
*.server[1].OS_scheduler.S[*].sleepTime = 9s
*.server[1].OS_scheduler.S[*].scheduleShare = 3s
*.server[1].OS_scheduler.S[*].schedulerStatus = true
*.server[1].OS_scheduler.Q[*].capacity = 4


# Third server has 10 VMs
*.server[2].vm[0].localPort = 601
*.server[2].vm[1].localPort = 602
*.server[2].vm[2].localPort = 603
*.server[2].vm[3].localPort = 604
*.server[2].vm[4].localPort = 605
*.server[2].vm[5].localPort = 606
*.server[2].vm[6].localPort = 607
*.server[2].vm[7].localPort = 608
*.server[2].vm[8].localPort = 609
*.server[2].vm[9].localPort = 610
*.client[2*].app[*].connectPort = int(uniform(600,610))
*.client[3*].app[*].connectPort = int(uniform(600,611))
*.client[4*].app[*].connectPort = int(uniform(600,610))
*.client[5*].app[*].connectPort = int(uniform(600,611))

*.server[2].OS_scheduler.S[*].serviceTime = exponential(3s) 
*.server[2].OS_scheduler.S[*].sleepTime = 27s
*.server[2].OS_scheduler.S[*].scheduleShare = 3s
*.server[2].OS_scheduler.S[*].schedulerStatus = true
*.server[2].OS_scheduler.Q[*].capacity = 7


#server 4 has 20 VMs
*.server[3].vm[0].localPort = 701
*.server[3].vm[1].localPort = 702
*.server[3].vm[2].localPort = 703
*.server[3].vm[3].localPort = 704
*.server[3].vm[4].localPort = 705
*.server[3].vm[5].localPort = 706
*.server[3].vm[6].localPort = 707
*.server[3].vm[7].localPort = 708
*.server[3].vm[8].localPort = 709
*.server[3].vm[9].localPort = 710
*.server[3].vm[10].localPort = 711
*.server[3].vm[11].localPort = 712
*.server[3].vm[12].localPort = 713
*.server[3].vm[13].localPort = 714
*.server[3].vm[14].localPort = 715
*.server[3].vm[15].localPort = 716
*.server[3].vm[16].localPort = 717
*.server[3].vm[17].localPort = 718
*.server[3].vm[18].localPort = 719
*.server[3].vm[19].localPort = 720
*.client[6*].app[*].connectPort = int(uniform(700,721))
*.client[7*].app[*].connectPort = int(uniform(701,721))
*.client[8*].app[*].connectPort = int(uniform(701,721))
*.client[9*].app[*].connectPort = int(uniform(700,721))


*.server[3].OS_scheduler.S[*].serviceTime = exponential(3s) 
*.server[3].OS_scheduler.S[*].sleepTime = 57s
*.server[3].OS_scheduler.S[*].scheduleShare = 3s
*.server[3].OS_scheduler.S[*].schedulerStatus = true
*.server[3].OS_scheduler.Q[*].capacity = 4


*.client[*].app[0].idleInterval = exponential(0.01s) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = exponential(0.1s)  # times between two requests, makes each session longer


[Config LOAD_Variation_SCHEDULING-EFFECT-Pretio-wl-10run-Scheduling-on-QDrop-off]
description = "It simulates pretio workload on cloud shared servers between 4 VMs,no Q drops, load varies over time dynamically"
# Here we implement load variation for the first 10 runs by bringing other apps running for a random time variation on VM by defining start and stop time
*.numClients = 30
*.numServers = 1
*.server[*].numVms = 4
#*.client[*].app[*]:vector.vector-recording = true
#*.client[*].app[*].connectPort = int(uniform(401,405))
*.client[0].app[0].connectPort = 401
*.client[1].app[0].connectPort = 402
*.client[2].app[0].connectPort = 402
*.client[3].app[0].connectPort = 403
*.client[4].app[0].connectPort = 403
*.client[5].app[0].connectPort = 403
*.client[6].app[0].connectPort = 404
*.client[7].app[0].connectPort = 404
*.client[8].app[0].connectPort = 404
*.client[9].app[0].connectPort = 404

*.client[1*].app[0].connectPort = int(uniform(400,405))
*.client[1*].app[*].startTime = int(uniform(5000s,15000s))
*.client[1*].app[*].stopTime = int(uniform(25000s,50000s))

*.client[2*].app[0].connectPort = int(uniform(400,405))
#*.client[2*].app[*].startTime = int(exponential(20000s))
#*.client[2*].app[*].stopTime = int(exponential(100000s))
*.client[2*].app[*].startTime = int(uniform(20000s,35000s))
*.client[2*].app[*].stopTime = int(uniform(45000s,65000s))

#*.client[3*].app[0].connectPort = int(uniform(400,405))
#*.client[3*].app[*].startTime = int(exponential(50000s))
#*.client[3*].app[*].stopTime = int(exponential(700000s))
#*.client[3*].app[*].startTime = int(uniform(40000s,50000s))
#*.client[3*].app[*].stopTime = int(uniform(60000s,90000s))


# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
#**.server[0].vm[4].localPort = 405
#**.server[0].vm[5].localPort = 406
#**.server[0].vm[6].localPort = 407
#**.server[0].vm[7].localPort = 408
#**.server[0].vm[8].localPort = 409
#**.server[0].vm[9].localPort = 410

*.server[*].OS_scheduler.S[*].serviceTime = exponential(4s) #in milliseconds actually 
*.server[*].OS_scheduler.S[*].sleepTime = exponential(20s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(4s)
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = 20

*.client[*].app[0].idleInterval = exponential(0.01s) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = exponential(1s)  # times between two requests, makes each session longer

[Config Pretio_Exact_LOAD_Variation_SCHEDULING-EFFECT-Pretio-wl-10run-Scheduling-on-QDrop-off]
description = "It simulates pretio workload on cloud shared servers between 4 VMs,no Q drops, load varies over time dynamically"
# Here we implement load variation for the first 10 runs by bringing other apps running for a random time variation on VM by defining start and stop time
*.numClients = 20
*.numServers = 1
*.server[*].numVms = 4
#*.client[*].app[*].connectPort = int(uniform(401,405))
#*.client[0].app[0].connectPort = 401
#*.client[1].app[0].connectPort = 402
#*.client[2].app[0].connectPort = 402
#*.client[3].app[0].connectPort = 403
#*.client[4].app[0].connectPort = 403
#*.client[5].app[0].connectPort = 403
#*.client[6].app[0].connectPort = 404
#*.client[7].app[0].connectPort = 404
#*.client[8].app[0].connectPort = 404
#*.client[9].app[0].connectPort = 404

*.client[*].app[0].connectPort = int(uniform(400,405))
*.client[*].app[*].startTime = int(uniform(10s,15000s))
*.client[*].app[*].stopTime = int(uniform(25000s,43000s))

#*.client[2*].app[0].connectPort = int(uniform(400,405))
#*.client[2*].app[*].startTime = int(exponential(20000s))
#*.client[2*].app[*].stopTime = int(exponential(100000s))
#*.client[2*].app[*].startTime = int(uniform(20000s,35000s))
#*.client[2*].app[*].stopTime = int(uniform(45000s,65000s))

#*.client[3*].app[0].connectPort = int(uniform(400,405))
#*.client[3*].app[*].startTime = int(exponential(50000s))
#*.client[3*].app[*].stopTime = int(exponential(700000s))
#*.client[3*].app[*].startTime = int(uniform(40000s,50000s))
#*.client[3*].app[*].stopTime = int(uniform(60000s,90000s))


# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
#**.server[0].vm[4].localPort = 405
#**.server[0].vm[5].localPort = 406
#**.server[0].vm[6].localPort = 407
#**.server[0].vm[7].localPort = 408
#**.server[0].vm[8].localPort = 409
#**.server[0].vm[9].localPort = 410

*.server[*].OS_scheduler.S[*].serviceTime = exponential(5s) #in milliseconds actually 
*.server[*].OS_scheduler.S[*].sleepTime = exponential(16s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(5s)
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = 20

*.client[*].app[0].idleInterval = exponential(0.01s) # time between two sessions
#*.client[*].app[0].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
 *.client[*].app[0].numRequestsPerSession = 1+int(bernoulli(0.4))*int(binomial(5,0.27))
                                                                                      #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = exponential(1s)  # times between two requests, makes each session longer

[Config Bursty-Simple-requests]
description = "The requests are expected to have a bursty pattern"
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1
*.client[*].numApps = 100
*.client[*].app[*].idleInterval = int(exponential(0.5s)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9))

*.client[*].app[*].thinkTime = exponential(0.01s) # makes each session longer
*.client[*].app[*].connectPort = 404
# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 404
*.server[*].OS_scheduler.S[*].serviceTime = exponential(1s) #in milliseconds actually 
*.server[*].OS_scheduler.S[*].sleepTime = exponential(20s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(5s)
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = 200

###########################################################################BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBb

[Config Bursty-Simple-requests-2]
description = "The requests are expected to have a bursty pattern"
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1
*.client[*].numApps = 100
*.client[*].app[*].idleInterval = int(exponential(0.5s)) # time between two sessions
#*.client[*].app[*].numRequestsPerSession = 1+int(binomial(3,0.5))
*.client[*].app[*].numRequestsPerSession = 2
*.client[*].app[*].thinkTime = exponential(0.01s) # makes each session longer
*.client[*].app[*].connectPort = 404
*.client[*].app[*].startTime = int(uniform(10s,5000s))
*.client[*].app[*].stopTime = int(uniform(75000s,80000s))
# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 404
*.server[*].OS_scheduler.S[*].serviceTime = exponential(1s) #in milliseconds actually 
*.server[*].OS_scheduler.S[*].sleepTime = exponential(20s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(5s)
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = 200

[Config Bursty-Simple-requests-3]
description = "The requests are expected to have a bursty pattern"
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1
*.client[*].numApps = 100
*.client[*].app[*].idleInterval = int(exponential(0.5s)) # time between two sessions
#*.client[*].app[*].numRequestsPerSession = 1+int(binomial(3,0.5))
*.client[*].app[*].numRequestsPerSession = 1
*.client[*].app[*].thinkTime = exponential(0.01s) # makes each session longer
*.client[*].app[*].connectPort = 404
*.client[*].app[*].startTime = int(uniform(10s,5000s))
*.client[*].app[*].stopTime = int(uniform(75000s,80000s))
# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 404
*.server[*].OS_scheduler.S[*].serviceTime = exponential(1s) #in milliseconds actually 
*.server[*].OS_scheduler.S[*].sleepTime = exponential(20s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(5s)
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = 200
#####################BBBBBBBBBBBBBBBBBBBBBBBBBBB############################BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
[Config Bursty-ON-OFF-requests2]
description = "The requests are expected to have a bursty pattern"
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1
*.client[*].numApps = 1
*.client[*].app[*].idleInterval = int(exponential(1000s)) # time between two sessions
#*.client[*].app[*].numRequestsPerSession = 1+int(binomial(3,0.5))
*.client[*].app[*].numRequestsPerSession = int(exponential(1000))
*.client[*].app[*].thinkTime = exponential(0.01s) # makes each session longer
*.client[*].app[*].connectPort = 404
#*.client[*].app[*].startTime = int(uniform(10s,10000s))
#*.client[*].app[*].stopTime = int(uniform(75000s,80000s))
# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 404
*.server[*].OS_scheduler.S[*].serviceTime = exponential(1s) #in milliseconds actually 
*.server[*].OS_scheduler.S[*].sleepTime = exponential(20s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(5s)
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = 2000

#####################################BBBBBBBBBBBBBB44444444444444444444444444444444444444444444444444444444444
[Config Bursty-Simple-requests-4]
description = "The requests are expected to have a bursty pattern"
*.numClients = 20
*.numServers = 1
*.server[*].numVms = 1
*.server[*].vm[*].replyDelay= exponential(0.1s)
*.client[*].numApps = 1
*.client[*].app[*].idleInterval = int(exponential(10s)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9))

*.client[*].app[*].thinkTime = exponential(0.01s) # makes each session longer
*.client[*].app[*].connectPort = 404
# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 404
*.server[*].OS_scheduler.S[*].serviceTime = exponential(0.1s) #in seconds actually 
*.server[*].OS_scheduler.S[*].sleepTime = exponential(19s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(1s)
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = 200













[Config MATLAB-Pretio-wl-10-VMs-Scheduling-is-off-QDrop-off]
description = "It simulates pretio workload on cloud shared servers between 10 VMs,no Q drops, No different loads"
*.numClients = 20
*.numServers = 1
*.server[*].numVms = 10
*.client[0].app[0].connectPort = 401
*.client[1].app[0].connectPort = 402
*.client[2].app[0].connectPort = 403
*.client[3].app[0].connectPort = 404
*.client[4].app[0].connectPort = 405
*.client[5].app[0].connectPort = 406
*.client[6].app[0].connectPort = 407
*.client[7].app[0].connectPort = 408
*.client[8].app[0].connectPort = 409
*.client[9].app[0].connectPort = 410
*.client[10].app[0].connectPort = 401
*.client[11].app[0].connectPort = 402
*.client[12].app[0].connectPort = 403
*.client[13].app[0].connectPort = 404
*.client[14].app[0].connectPort = 405
*.client[15].app[0].connectPort = 406
*.client[16].app[0].connectPort = 407
*.client[17].app[0].connectPort = 408
*.client[18].app[0].connectPort = 409
*.client[19].app[0].connectPort = 410
# Another choice of server app (it does the same as Tcp

# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
**.server[0].vm[4].localPort = 405
**.server[0].vm[5].localPort = 406
**.server[0].vm[6].localPort = 407
**.server[0].vm[7].localPort = 408
**.server[0].vm[8].localPort = 409
**.server[0].vm[9].localPort = 410

*.server[*].OS_scheduler.S[*].serviceTime = exponential(1s) 
*.server[*].OS_scheduler.S[*].sleepTime = exponential(0.09s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(0.01s)
*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.Q[*].capacity = -1

*.client[*].app[0].idleInterval = exponential(1s) # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(binomial(5,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = exponential(10ms)  # times between two requests, makes each session longer

[Config MATLAB-Pretio-wl-10-runs-Scheduling-is-off-QDrop-is-on]
description = "It simulates pretio workload on cloud shared servers between 10 VMs,no Q drops, No different loads"
*.numClients = 20
*.numServers = 1
*.server[*].numVms = 10
*.client[0].app[0].connectPort = 401
*.client[1].app[0].connectPort = 402
*.client[2].app[0].connectPort = 403
*.client[3].app[0].connectPort = 404
*.client[4].app[0].connectPort = 405
*.client[5].app[0].connectPort = 406
*.client[6].app[0].connectPort = 407
*.client[7].app[0].connectPort = 408
*.client[8].app[0].connectPort = 409
*.client[9].app[0].connectPort = 410
*.client[10].app[0].connectPort = 401
*.client[11].app[0].connectPort = 402
*.client[12].app[0].connectPort = 403
*.client[13].app[0].connectPort = 404
*.client[14].app[0].connectPort = 405
*.client[15].app[0].connectPort = 406
*.client[16].app[0].connectPort = 407
*.client[17].app[0].connectPort = 408
*.client[18].app[0].connectPort = 409
*.client[19].app[0].connectPort = 410
# Another choice of server app (it does the same as Tcp

# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
**.server[0].vm[4].localPort = 405
**.server[0].vm[5].localPort = 406
**.server[0].vm[6].localPort = 407
**.server[0].vm[7].localPort = 408
**.server[0].vm[8].localPort = 409
**.server[0].vm[9].localPort = 410


*.server[*].OS_scheduler.S[*].serviceTime = exponential(1s) 
*.server[*].OS_scheduler.S[*].sleepTime = exponential(0.8s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(0.2s)
*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.Q[*].capacity = 4

*.client[*].app[0].idleInterval = 1s # time between two sessions
*.client[*].app[0].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[0].thinkTime = exponential(10ms)  # times between two requests, makes each session longer

[Config MATLAB-Pretio-wl-10-runs-2app-Scheduling-is-off-QDrop-is-on]
description = "It simulates pretio workload on cloud shared servers between 10 VMs,no Q drops, No different loads"
*.numClients = 10
*.numServers = 1
*.server[*].numVms = 10
*.client[*].numApps = 2
*.client[0].app[*].connectPort = 401
*.client[1].app[*].connectPort = 402
*.client[2].app[*].connectPort = 403
*.client[3].app[*].connectPort = 404
*.client[4].app[*].connectPort = 405
*.client[5].app[*].connectPort = 406
*.client[6].app[*].connectPort = 407
*.client[7].app[*].connectPort = 408
*.client[8].app[*].connectPort = 409
*.client[9].app[*].connectPort = 410
#*.client[10].app[0].connectPort = 401
#*.client[11].app[0].connectPort = 402
#*.client[12].app[0].connectPort = 403
#*.client[13].app[0].connectPort = 404
#*.client[14].app[0].connectPort = 405
#*.client[15].app[0].connectPort = 406
#*.client[16].app[0].connectPort = 407
#*.client[17].app[0].connectPort = 408
#*.client[18].app[0].connectPort = 409
#*.client[19].app[0].connectPort = 410
# Another choice of server app (it does the same as Tcp

# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
**.server[0].vm[4].localPort = 405
**.server[0].vm[5].localPort = 406
**.server[0].vm[6].localPort = 407
**.server[0].vm[7].localPort = 408
**.server[0].vm[8].localPort = 409
**.server[0].vm[9].localPort = 410


*.server[*].OS_scheduler.S[*].serviceTime = exponential(1s)  #simulates the time needed by each VM to process the request
*.server[*].OS_scheduler.S[*].sleepTime = exponential(0.8s)  #simulates round robin on physical host
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(0.2s)
*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.Q[*].capacity = 5

#*.client[*].app[0].idleInterval = exponential(0.001s) # time between two sessions
*.client[*].app[*].idleInterval = 1s# time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(5,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[*].thinkTime = exponential(10ms)  # times between two requests, makes each session longer

[Config MATLAB-Pretio-wl-1-run-Scheduling-is-off-QDrop-is-on]
description = "It simulates pretio workload on cloud shared servers between 10 VMs,no Q drops, No different loads"
*.numClients = 1
*.numServers = 1
*.client[*].numApps = 2
*.server[*].numVms = 1
*.client[0].app[*].connectPort = 401
# Another choice of server app (it does the same as Tcp

# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401


*.server[*].OS_scheduler.S[*].serviceTime = exponential(1s)  #simulates the time needed by each VM to process the request
*.server[*].OS_scheduler.S[*].sleepTime = exponential(0.8s)  #simulates round robin on physical host
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(0.2s)
*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.Q[*].capacity = 6

#*.client[*].app[0].idleInterval = exponential(0.001s) # time between two sessions
*.client[*].app[*].idleInterval = 1s# time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(5,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[*].thinkTime = 0s  # times between two requests, makes each session longer

[Config MATLAB-Pretio-wl-10-runs-Scheduling-is-on-QDrop-is-on-new]
description = "It simulates pretio workload on cloud shared servers between 10 VMs,no Q drops, No different loads"
*.numClients = 10
*.server[*].numVms = 4
*.numServers = 1
*.client[*].numApps = 2
*.client[*].app[*].connectPort = int(uniform(399,404))
#*.client[10].app[0].connectPort = 401
#*.client[11].app[0].connectPort = 402
#*.client[12].app[0].connectPort = 403
#*.client[13].app[0].connectPort = 404
#*.client[14].app[0].connectPort = 405
#*.client[15].app[0].connectPort = 406
#*.client[16].app[0].connectPort = 407
#*.client[17].app[0].connectPort = 408
#*.client[18].app[0].connectPort = 409
#*.client[19].app[0].connectPort = 410
# Another choice of server app (it does the same as Tcp

# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 400
**.server[0].vm[1].localPort = 401
**.server[0].vm[2].localPort = 402
**.server[0].vm[3].localPort = 403
**.server[0].vm[4].localPort = 404
**.server[0].vm[5].localPort = 406
**.server[0].vm[6].localPort = 407
**.server[0].vm[7].localPort = 408
**.server[0].vm[8].localPort = 409
**.server[0].vm[9].localPort = 410


*.server[*].OS_scheduler.S[*].serviceTime = exponential(1s) 
*.server[*].OS_scheduler.S[*].sleepTime = exponential(5s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(2s)
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = 25

*.client[*].app[*].idleInterval = exponential(1s) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(5,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[*].thinkTime = exponential(10ms)  # times between two requests, makes each session longer


[Config MATLAB-Pretio-wl-10-runs-Scheduling-is-on-QDrop-is-off]
description = "It simulates pretio workload on cloud shared servers between 10 VMs,no Q drops, No different loads"
*.numClients = 10
*.numServers = 1
*.server[*].numVms = 4
*.client[*].numApps = 2
*.client[*].app[*].connectPort = int(uniform(400,405))
#*.client[10].app[0].connectPort = 401
#*.client[11].app[0].connectPort = 402
#*.client[12].app[0].connectPort = 403
#*.client[13].app[0].connectPort = 404
#*.client[14].app[0].connectPort = 405
#*.client[15].app[0].connectPort = 406
#*.client[16].app[0].connectPort = 407
#*.client[17].app[0].connectPort = 408
#*.client[18].app[0].connectPort = 409
#*.client[19].app[0].connectPort = 410
# Another choice of server app (it does the same as Tcp

# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 401
**.server[0].vm[1].localPort = 402
**.server[0].vm[2].localPort = 403
**.server[0].vm[3].localPort = 404
**.server[0].vm[4].localPort = 405
**.server[0].vm[5].localPort = 406
**.server[0].vm[6].localPort = 407
**.server[0].vm[7].localPort = 408
**.server[0].vm[8].localPort = 409
**.server[0].vm[9].localPort = 410


*.server[*].OS_scheduler.S[*].serviceTime = exponential(1s) 
*.server[*].OS_scheduler.S[*].sleepTime = exponential(5s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(2s)
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = -1

*.client[*].app[*].idleInterval = exponential(1s) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(5,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[*].thinkTime = exponential(10ms)  # times between two requests, makes each session longer


##########################################################

[Config MATLAB-Pretio-wl-100-runs-Scheduling-is-on-QDrop-is-on-new2]
description = "It simulates pretio workload on cloud shared servers between 10 VMs,no Q drops, No different loads"
*.numClients = 20
*.server[*].numVms = 7
*.numServers = 1
*.client[*].numApps = 5
*.client[*].app[*].connectPort = int(uniform(400,407))
#*.client[10].app[0].connectPort = 401
#*.client[11].app[0].connectPort = 402
#*.client[12].app[0].connectPort = 403
#*.client[13].app[0].connectPort = 404
#*.client[14].app[0].connectPort = 405
#*.client[15].app[0].connectPort = 406
#*.client[16].app[0].connectPort = 407
#*.client[17].app[0].connectPort = 408
#*.client[18].app[0].connectPort = 409
#*.client[19].app[0].connectPort = 410
# Another choice of server app (it does the same as Tcp

# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 400
**.server[0].vm[1].localPort = 401
**.server[0].vm[2].localPort = 402
**.server[0].vm[3].localPort = 403
**.server[0].vm[4].localPort = 404
**.server[0].vm[5].localPort = 405
**.server[0].vm[6].localPort = 406
**.server[0].vm[7].localPort = 407
**.server[0].vm[8].localPort = 408
**.server[0].vm[9].localPort = 409


*.server[*].OS_scheduler.S[*].serviceTime = 1s 
*.server[*].OS_scheduler.S[*].sleepTime = 6s
*.server[*].OS_scheduler.S[*].scheduleShare = 2s
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = 100

*.client[*].app[*].idleInterval = exponential(10ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(5,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[*].thinkTime = exponential(10ms)  # times between two requests, makes each session longer

#########################################################  1 req/session

[Config MATLAB-the-most-simple-wl-100-runs-Scheduling-is-on-QDrop-is-on-new2]
description = "It simulates pretio workload on cloud shared servers between 10 VMs,no Q drops, No different loads"
*.numClients = 20
*.server[*].numVms = 7
*.numServers = 1
*.client[*].numApps = 5
*.client[*].app[*].connectPort = int(uniform(400,407))
#*.client[10].app[0].connectPort = 401
#*.client[11].app[0].connectPort = 402
#*.client[12].app[0].connectPort = 403
#*.client[13].app[0].connectPort = 404
#*.client[14].app[0].connectPort = 405
#*.client[15].app[0].connectPort = 406
#*.client[16].app[0].connectPort = 407
#*.client[17].app[0].connectPort = 408
#*.client[18].app[0].connectPort = 409
#*.client[19].app[0].connectPort = 410
# Another choice of server app (it does the same as Tcp

# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 400
**.server[0].vm[1].localPort = 401
**.server[0].vm[2].localPort = 402
**.server[0].vm[3].localPort = 403
**.server[0].vm[4].localPort = 404
**.server[0].vm[5].localPort = 405
**.server[0].vm[6].localPort = 406
**.server[0].vm[7].localPort = 407
**.server[0].vm[8].localPort = 408
**.server[0].vm[9].localPort = 409


*.server[*].OS_scheduler.S[*].serviceTime = int(uniform(500ms,800ms))#normal(1000ms,100ms)#exponential(500ms) 
*.server[*].OS_scheduler.S[*].sleepTime = exponential(5s)
*.server[*].OS_scheduler.S[*].scheduleShare = int(uniform(1500ms,2500ms))#exponential(1s)
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = 50

*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(5,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[*].thinkTime = exponential(10ms)  # times between two requests, makes each session longer


#########################################################                          100                  ####################################################
[Config MATLAB-Pretio-wl-100-runs-4servers-Scheduling-is-on-QDrop-is-on-new]
description = "It simulates pretio workload on cloud shared servers between different number of VMs,Q drops, No different loads"
*.client[*].numApps = 1
*.numClients = 100
*.numServers = 4
*.server[0].numVms = 1
*.server[1].numVms = 4
*.server[2].numVms = 10
*.server[3].numVms = 20

*.client[0].app[*].connectAddress = "server[0]"
*.client[1].app[*].connectAddress = "server[0]"
*.client[2].app[*].connectAddress = "server[0]"
*.client[3].app[*].connectAddress = "server[0]"
*.client[4].app[*].connectAddress = "server[0]"
*.client[5].app[*].connectAddress = "server[0]"
*.client[6].app[*].connectAddress = "server[0]"
*.client[7].app[*].connectAddress = "server[0]"
*.client[8].app[*].connectAddress = "server[0]"
*.client[9].app[*].connectAddress = "server[0]"

*.client[1*].app[*].connectAddress = "server[1]"

*.client[2*].app[*].connectAddress = "server[2]"
*.client[3*].app[*].connectAddress = "server[2]"
*.client[4*].app[*].connectAddress = "server[2]"
*.client[5*].app[*].connectAddress = "server[2]"

*.client[6*].app[*].connectAddress = "server[3]"
*.client[7*].app[*].connectAddress = "server[3]"
*.client[8*].app[*].connectAddress = "server[3]"
*.client[9*].app[*].connectAddress = "server[3]"



# First server has one VM and that VM has 10 containers
*.server[0].vm[0].localPort = 401
*.client[0].app[*].connectPort = 401
*.client[1].app[*].connectPort = 401
*.client[2].app[*].connectPort = 401
*.client[3].app[*].connectPort = 401
*.client[4].app[*].connectPort = 401
*.client[5].app[*].connectPort = 401
*.client[6].app[*].connectPort = 401
*.client[7].app[*].connectPort = 401
*.client[8].app[*].connectPort = 401
*.client[9].app[*].connectPort = 401

*.server[0].OS_scheduler.S[*].serviceTime = exponential(0.3s) 
*.server[0].OS_scheduler.S[*].sleepTime = 3s
*.server[0].OS_scheduler.S[*].scheduleShare = 1s
*.server[0].OS_scheduler.S[*].schedulerStatus = true
*.server[0].OS_scheduler.Q[*].capacity = 40

# second server has 5 VMs and each VM has different number of containers.

**.server[1].vm[0].localPort = 501
**.server[1].vm[1].localPort = 502
**.server[1].vm[2].localPort = 503
**.server[1].vm[3].localPort = 504
*.client[1*].app[*].connectPort = int(uniform(500,505))


*.server[1].OS_scheduler.S[*].serviceTime = exponential(0.3s) 
*.server[1].OS_scheduler.S[*].sleepTime = 9s
*.server[1].OS_scheduler.S[*].scheduleShare = 3s
*.server[1].OS_scheduler.S[*].schedulerStatus = true
*.server[1].OS_scheduler.Q[*].capacity = 20


# Third server has 10 VMs
*.server[2].vm[0].localPort = 601
*.server[2].vm[1].localPort = 602
*.server[2].vm[2].localPort = 603
*.server[2].vm[3].localPort = 604
*.server[2].vm[4].localPort = 605
*.server[2].vm[5].localPort = 606
*.server[2].vm[6].localPort = 607
*.server[2].vm[7].localPort = 608
*.server[2].vm[8].localPort = 609
*.server[2].vm[9].localPort = 610
*.client[2*].app[*].connectPort = int(uniform(600,611))
*.client[3*].app[*].connectPort = int(uniform(600,611))
*.client[4*].app[*].connectPort = int(uniform(600,611))
*.client[5*].app[*].connectPort = int(uniform(600,611))

*.server[2].OS_scheduler.S[*].serviceTime = exponential(0.3s) 
*.server[2].OS_scheduler.S[*].sleepTime = 27s
*.server[2].OS_scheduler.S[*].scheduleShare = 3s
*.server[2].OS_scheduler.S[*].schedulerStatus = true
*.server[2].OS_scheduler.Q[*].capacity = 20


#server 4 has 20 VMs
*.server[3].vm[0].localPort = 701
*.server[3].vm[1].localPort = 702
*.server[3].vm[2].localPort = 703
*.server[3].vm[3].localPort = 704
*.server[3].vm[4].localPort = 705
*.server[3].vm[5].localPort = 706
*.server[3].vm[6].localPort = 707
*.server[3].vm[7].localPort = 708
*.server[3].vm[8].localPort = 709
*.server[3].vm[9].localPort = 710
*.server[3].vm[10].localPort = 711
*.server[3].vm[11].localPort = 712
*.server[3].vm[12].localPort = 713
*.server[3].vm[13].localPort = 714
*.server[3].vm[14].localPort = 715
*.server[3].vm[15].localPort = 716
*.server[3].vm[16].localPort = 717
*.server[3].vm[17].localPort = 718
*.server[3].vm[18].localPort = 719
*.server[3].vm[19].localPort = 720
*.client[6*].app[*].connectPort = int(uniform(700,721))
*.client[7*].app[*].connectPort = int(uniform(700,721))
*.client[8*].app[*].connectPort = int(uniform(700,721))
*.client[9*].app[*].connectPort = int(uniform(700,721))


*.server[3].OS_scheduler.S[*].serviceTime = exponential(0.3s) 
*.server[3].OS_scheduler.S[*].sleepTime = 57s
*.server[3].OS_scheduler.S[*].scheduleShare = 3s
*.server[3].OS_scheduler.S[*].schedulerStatus = true
*.server[3].OS_scheduler.Q[*].capacity = 20


*.client[*].app[*].idleInterval = exponential(0.01s) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(5,0.8)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[*].thinkTime = exponential(0.01s)  # times between two requests, makes each session longer



#########################################            100               BURSTY TRAFFIC
##############Everything the same just the coming traffic is bursty
[Config MATLAB-Bursty-100-runs-Scheduling-is-on-QDrop-is-on-new2]
description = "It simulates bursty workload on cloud shared servers between 10 VMs,Q drops, scheduling  "
*.numClients = 20
*.server[*].numVms = 10
*.numServers = 1
*.client[*].numApps = 5
*.client[*].app[*].connectPort = int(uniform(400,407))
#*.client[10].app[0].connectPort = 401
#*.client[11].app[0].connectPort = 402
#*.client[12].app[0].connectPort = 403
#*.client[13].app[0].connectPort = 404
#*.client[14].app[0].connectPort = 405
#*.client[15].app[0].connectPort = 406
#*.client[16].app[0].connectPort = 407
#*.client[17].app[0].connectPort = 408
#*.client[18].app[0].connectPort = 409
#*.client[19].app[0].connectPort = 410
# Another choice of server app (it does the same as Tcp

# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 400
**.server[0].vm[1].localPort = 401
**.server[0].vm[2].localPort = 402
**.server[0].vm[3].localPort = 403
**.server[0].vm[4].localPort = 404
**.server[0].vm[5].localPort = 405
**.server[0].vm[6].localPort = 406
**.server[0].vm[7].localPort = 407
**.server[0].vm[8].localPort = 408
**.server[0].vm[9].localPort = 409

# This scheduler schedules between different VMs on one server
*.server[*].OS_scheduler.S[*].serviceTime = exponential(1s) # we added this to simulate the hardware time needed  
*.server[*].OS_scheduler.S[*].sleepTime = exponential(4s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(2s)
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = 64

#* Returns the result of a Bernoulli trial with probability p,
#*     * that is, 1 with probability p and 0 with probability (1-p).
#*     *
#*     * Generation is using elementary look-up.
#*     *
#*     * @param p  0=<p<=1
#*     * @param rng index of the component RNG to use, see getRNG(int)


*.client[*].app[*].idleInterval = int(bernoulli(0.1))*100s#pareto_shifted(1,1s,0,0)#exponential(1s) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(5,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[*].thinkTime = exponential(10ms)  # times between two requests, makes each session longer

[Config MATLAB-Bursty-20-runs-pretio-Scheduling-is-on-QDrop-is-on-new2]
description = "It simulates bursty workload on cloud shared servers between 10 VMs,Q drops, scheduling  "
*.numClients = 20
*.server[*].numVms = 10
*.numServers = 1
*.client[*].numApps = 5
*.client[*].app[*].connectPort = int(uniform(400,407))
#*.client[10].app[0].connectPort = 401
#*.client[11].app[0].connectPort = 402
#*.client[12].app[0].connectPort = 403
#*.client[13].app[0].connectPort = 404
#*.client[14].app[0].connectPort = 405
#*.client[15].app[0].connectPort = 406
#*.client[16].app[0].connectPort = 407
#*.client[17].app[0].connectPort = 408
#*.client[18].app[0].connectPort = 409
#*.client[19].app[0].connectPort = 410
# Another choice of server app (it does the same as Tcp

# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 400
**.server[0].vm[1].localPort = 401
**.server[0].vm[2].localPort = 402
**.server[0].vm[3].localPort = 403
**.server[0].vm[4].localPort = 404
**.server[0].vm[5].localPort = 405
**.server[0].vm[6].localPort = 406
**.server[0].vm[7].localPort = 407
**.server[0].vm[8].localPort = 408
**.server[0].vm[9].localPort = 409

# This scheduler schedules between different VMs on one server
*.server[*].OS_scheduler.S[*].serviceTime = exponential(1s) # we added this to simulate the hardware time needed  
*.server[*].OS_scheduler.S[*].sleepTime = exponential(5s)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(2s)
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = 25
 
 #    * @param a,b  the usual parameters for generalized Pareto
 #    * @param c    shift parameter for left-shift
 #    * @param rng index of the component RNG to use, see getRNG(int)
 #    */
 #   virtual double pareto_shifted(double a, double b, double c, int rng=0) const  {return omnetpp::pareto_shifted(getRNG(rng), a, b, c);};
*.client[*].app[*].idleInterval = int(bernoulli(0.1))*pareto_shifted(1,1s,0,0)#exponential(1s) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(5,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[*].thinkTime = int(bernoulli(0.1))*pareto_shifted(1,1s,0,0)  # times between two requests, makes each session longer

[Config TEST-Bursty-10-runs-Scheduling-is-on-QDrop-is-on-new2]
description = "It simulates bursty workload on cloud shared servers between 10 VMs,Q drops, scheduling  "
*.numClients = 10
*.server[*].numVms = 4
*.numServers = 1
*.client[*].numApps = 1
*.client[*].app[*].connectPort = int(uniform(399,403))
#*.client[*].app[*].connectPort = 400
#*.client[11].app[0].connectPort = 402
#*.client[12].app[0].connectPort = 403
#*.client[13].app[0].connectPort = 404
#*.client[14].app[0].connectPort = 405
#*.client[15].app[0].connectPort = 406
#*.client[16].app[0].connectPort = 407
#*.client[17].app[0].connectPort = 408
#*.client[18].app[0].connectPort = 409
#*.client[19].app[0].connectPort = 410
# Another choice of server app (it does the same as Tcp

# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 400
**.server[0].vm[1].localPort = 401
**.server[0].vm[2].localPort = 402
**.server[0].vm[3].localPort = 403
#**.server[0].vm[4].localPort = 404
#**.server[0].vm[5].localPort = 405
#**.server[0].vm[6].localPort = 406
#**.server[0].vm[7].localPort = 407
#**.server[0].vm[8].localPort = 408
#**.server[0].vm[9].localPort = 409

# This scheduler schedules between different VMs on one server
*.server[*].OS_scheduler.S[*].serviceTime = 1s 
*.server[*].OS_scheduler.S[*].sleepTime = 6s
*.server[*].OS_scheduler.S[*].scheduleShare = 2s
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = 10

*.client[*].app[*].idleInterval = int(bernoulli(0.1))*100#*pareto_shifted(2,1s,2,0) # time between two sessions here we want no idle time
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(5,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[*].thinkTime = exponential(100ms)  # times between two requests, makes each session longer



[Config TEST-Bursty-10-runs-in-seq-Scheduling-is-on-QDrop-is-on-new2]
description = "It simulates bursty workload on cloud shared servers between 10 VMs,Q drops, scheduling  "
*.numClients = 1
*.server[*].numVms = 1
*.numServers = 1
*.client[*].numApps = 1
#*.client[*].app[*].connectPort = int(uniform(399,403))
*.client[*].app[*].connectPort = 400
#*.client[11].app[0].connectPort = 402
#*.client[12].app[0].connectPort = 403
#*.client[13].app[0].connectPort = 404
#*.client[14].app[0].connectPort = 405
#*.client[15].app[0].connectPort = 406
#*.client[16].app[0].connectPort = 407
#*.client[17].app[0].connectPort = 408
#*.client[18].app[0].connectPort = 409
#*.client[19].app[0].connectPort = 410
# Another choice of server app (it does the same as Tcp

# Another choice of server app (it does the same as TcpGenericServerApp):
#  **.srv.app[*].typename="TcpServerHostApp"
#  **.srv.app[0].serverThreadClass="TcpGenericServerThread"
**.server[0].vm[0].localPort = 400
#**.server[0].vm[1].localPort = 401
#**.server[0].vm[2].localPort = 402
#**.server[0].vm[3].localPort = 403
#**.server[0].vm[4].localPort = 404
#**.server[0].vm[5].localPort = 405
#**.server[0].vm[6].localPort = 406
#**.server[0].vm[7].localPort = 407
#**.server[0].vm[8].localPort = 408
#**.server[0].vm[9].localPort = 409

# This scheduler schedules between different VMs on one server
*.server[*].OS_scheduler.S[*].serviceTime = exponential(100ms)
*.server[*].OS_scheduler.S[*].sleepTime = exponential(300ms)
*.server[*].OS_scheduler.S[*].scheduleShare = exponential(200ms)
*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.Q[*].capacity = 10

*.client[*].app[*].idleInterval = int(bernoulli(0.1))*100s#*pareto_shifted(2,1s,2,0) # time between two sessions here we want no idle time
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(5,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
*.client[*].app[*].thinkTime = exponential(100ms)  # times between two requests, makes each session longer
