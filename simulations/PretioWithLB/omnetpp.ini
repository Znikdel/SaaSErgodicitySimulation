[General]
network = PretioWithLB
**.scalar-recording = true
**.vector-recording = false
cmdenv-interactive = true
**.cmdenv-log-level = off
# How to run frm command line?  opp_runall ./ErgodicityTest -u Cmdenv --sim-time-limit=1000s -f ../simulations/PretioWithLB/omnetpp.ini -c Scenario1-Type1-Short-Sessions
num-rngs = 2
ned-path=../../simulations;../../src;../../../inet4/src;../../../inet4/examples;../../../inet4/tutorials;../../../inet4/showcases;../../../neddemo;../../../queueinglib;../../../queueinglibext;../../../routing;../../../sockets;
**.cloudNetwork.ipv4Delayer.rng-0 = 1
**.cloudNetwork.ipv4Delayer.config = xmldoc("./../simulations/PretioWithLB/internetCloud.xml")

*.numClients = 1
*.numServers = 1
*.client[*].numApps = 3
*.client[*].app[*].typename="ErgodicityTestClient"
*.client[*].app[*].connectAddress = "server[0]"

#*.client[*].app[*].requestLength = 1B*int(truncnormal(150,10))
#*.client[*].app[*].replyLength = 1B*int(truncnormal(350,20))
*.client[*].app[*].requestLength = 64B
#*.client[*].app[*].replyLength = 64B  # Do not CHANGE , we use it to mark packets for reliable protocol
#*.client[*].numPcapRecorders = 1
#*.client[*].pcapRecorder[0].pcapFile = "results/client0.pcap"
#**.crcMode = "computed"
#**.fcsMode = "computed"
*.client[*].app[0].thinkTime = int(exponential(0.5s))
#time gap between sessions
*.client[*].app[0].idleInterval = int(exponential(1s))


*.server[*].numVms = 1
*.server[*].vm[*].typename = "tryServer"
*.server[*].vm[*].replyDelay= int(exponential(50ms))
*.server[*].ppp[*].ppp.queue.typename="DropTailQueue"
#*.server[*].OS_scheduler.S[*].serviceTime = exponential(2s)
*.server[*].OS_scheduler.Q[*].capacity = 10

**.ppp[*].ppp.queue.typename = "DropTailQueue" # in routers 
**.ppp[*].ppp.queue.packetCapacity = -1  # in routers
*.server[*].OS_scheduler.S[*].schedulerStatus = false

[Config forTest]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=1
seed-set = ${repetition}
*.numClients = int(uniform(10,14))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = int(uniform(401,405))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
#int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[0].app[*].startTime = int(uniform(1s,1000s))
*.client[1].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(8000s,10000s))
*.client[6].app[*].startTime = int(uniform(9000s,10000s))
*.client[7].app[*].startTime = int(uniform(10000s,12000s))
*.client[8].app[*].startTime = int(uniform(11000s,12000s))
*.client[9].app[*].startTime = int(uniform(15000s,16000s))
*.client[0].app[*].stopTime = 36000s
*.client[1].app[*].stopTime = int(uniform(7000s,9000s))
*.client[2].app[*].stopTime = int(uniform(8000s,10000s))
*.client[3].app[*].stopTime = int(uniform(13000s,18000s))
*.client[4].app[*].stopTime = int(uniform(16000s,23000s))
*.client[5].app[*].stopTime = int(uniform(18000s,24000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(22000s,27000s))
*.client[8].app[*].stopTime = int(uniform(15000s,36000s))
*.client[9].app[*].stopTime = int(uniform(18000s,30000s))

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                     
#--------------------------------------------------------------------------------------------------

[Config Test-nr]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=1
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.server[*].vm[*].replyDelay= int(uniform(30ms,50ms))
*.server[*].OS_scheduler.Q[*].RTOS = false
*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =300s
*.client[*].app[*].burstyTraffic=false
*.client[*].app[*].RTOS = true
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(uniform(300ms,500ms))
*.server[*].OS_scheduler.Q[*].capacity = 16
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(binomial(6,0.9))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                     
#1+int(bernoulli(0.4))#*3#int(binomial(6,0.9))
#1+int(bernoulli(0.4))*int(binomial(5,0.27)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
            #                                                                           #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#--------------------------------------------------------------------------------------------------


[Config Test-r]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 3000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].thinkTime = exponential(10ms)  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession =7# 1+int(bernoulli(0.4))*int(binomial(5,0.27)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
            #                                                                           #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#--------------------------------------------------------------------------------------------------
[Config Scenario1-Type1-Poisson-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 1000000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].reliableProtocol = true

*.client[*].app[*].thinkTime = exponential(10ms)  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(bernoulli(0.4))*int(binomial(5,0.27)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
            #                                                                           #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#----------------------------------------------------
[Config Scenario1-Type1-Poisson-not-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 1000000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].reliableProtocol = false

*.client[*].app[*].thinkTime = exponential(10ms)  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(bernoulli(0.4))*int(binomial(5,0.27)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
            #                                                                           #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#----------------------------------------------------
[Config Scenario1-Type1-Short-Sessions-Bursty-non-reliable-300]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.server[*].vm[*].replyDelay= int(exponential(20ms))

*.client[*].app[*].reliableProtocol = false

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =300s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions, in bursty to give some time to other requests to get processed
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario1-Type1-Short-Sessions-Bursty-reliable-300]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.server[*].vm[*].replyDelay= int(exponential(20ms))

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =300s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario1-Type1-Bursty-reliable-500]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = true
*.server[*].vm[*].replyDelay= int(exponential(20ms))

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =500s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(300ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario1-Type1-Bursty-not-reliable-500]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = false
*.server[*].vm[*].replyDelay= int(exponential(20ms))

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =500s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(300ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario1-Type2-Bursty-reliable-150]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.server[*].vm[*].replyDelay= int(exponential(20ms))

*.client[*].app[*].reliableProtocol = true

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =150s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(300ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = (exponential(100ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(200ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession =  1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario1-Type2-Bursty-reliable-300]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.server[*].vm[*].replyDelay= int(exponential(20ms))

*.client[*].app[*].reliableProtocol = true

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =300s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(300ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = (exponential(100ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(200ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession =  1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario1-Type2-Bursty-reliable-500]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.server[*].vm[*].replyDelay= int(exponential(20ms))

*.client[*].app[*].reliableProtocol = true

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =500s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(300ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession =  1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario1-Type2-Bursty-reliable-random-burst]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.server[*].vm[*].replyDelay= int(exponential(20ms))

*.client[*].app[*].reliableProtocol = true

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =0s
*.client[*].app[*].randomBurst=true
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(300ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession =  1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------

[Config Scenario1-Type2-Bursty-not-reliable-150]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = false
*.server[*].vm[*].replyDelay= int(exponential(20ms))

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =150s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(300ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession =  1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------

[Config Scenario1-Type2-Bursty-not-reliable-300]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.server[*].vm[*].replyDelay= int(exponential(20ms))

*.client[*].app[*].reliableProtocol = false

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =300s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(300ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession =  1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario1-Type2-Bursty-not-reliable-500]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = false
*.server[*].vm[*].replyDelay= int(exponential(20ms))

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =500s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(300ms)
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession =  1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------

[Config Scenario1-Type2-Poisson-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different parallel clients on the workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401
*.client[0].app[*].burstyTraffic=false
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 100000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].reliableProtocol = true

*.client[*].app[*].thinkTime = exponential(10ms)  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#--------------------------------------------


[Config Scenario1-Type2-Poisson-not-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # Here shows how much a burst is bigger than normal traffic e.g. *10
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = 1000000
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].reliableProtocol = false

*.client[*].app[*].thinkTime = exponential(10ms)  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#--------------------------------------------

[Config Scenario2-Type1-Poisson-Q-drops-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.client[*].app[*].reliableProtocol = true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(5,10))
*.server[*].OS_scheduler.S[*].schedulerStatus = false

*.client[*].app[*].thinkTime = exponential(10ms)  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(bernoulli(0.4))*int(binomial(5,0.27)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
            #                                                                           #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#----------------------------------------------------

[Config Scenario2-Type1-Poisson-Q-drops-not-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].reliableProtocol = false
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(5,10))
*.server[*].OS_scheduler.S[*].schedulerStatus = false

*.client[*].app[*].thinkTime = exponential(10ms)  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(bernoulli(0.4))*int(binomial(5,0.27)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
            #                                                                           #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#----------------------------------------------------
[Config Scenario2-Type1-Poisson-More-Q-drops-not-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].reliableProtocol = false
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(400ms)
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(4,11))
*.server[*].OS_scheduler.S[*].schedulerStatus = false

*.client[*].app[*].thinkTime = exponential(10ms)  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(bernoulli(0.4))*int(binomial(5,0.27)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
            #                                                                           #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial

#----------------------------------------------------
[Config Scenario2-Type1-Bursty-Q-drops-reliable-300]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = true

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =300s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(300ms)
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(200,300))
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
#----------------------------------------------------
[Config Scenario2-Type1-Bursty-Q-drops-not-reliable-300]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=1
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = false

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =300s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(300ms)
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(60,120))
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------

[Config Scenario2-Type2-Poisson-Q-drops-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401
*.client[*].app[*].reliableProtocol = true
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(400ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(4,9))
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario2-Type2-Poisson-Q-drops-not-reliable]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[0].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[0].app[*].connectPort = 401
**.server[0].vm[*].localPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(400ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(4,9))

*.client[*].app[*].reliableProtocol = false

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------


[Config Scenario2-Type2-Bursty-Q-drops-reliable-300]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = true

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =300s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(300ms)
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(300,400))
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------
[Config Scenario2-Type2-Bursty-Q-drops-not-reliable-300]
description = "The arrival of user-initiated sessions can be modeled as a Poisson distribution"
repeat=100
seed-set = ${repetition}
*.numClients = 1
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 100 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].connectPort = 401
**.server[0].vm[0].localPort = 401
*.client[*].app[*].reliableProtocol = false

*.client[*].app[*].startBurst = 1s
*.client[*].app[*].burstLen =300s
*.client[*].app[*].burstyTraffic=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is no scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = exponential(300ms)
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(60,120))
*.server[*].OS_scheduler.Q[*].fifo = true

*.client[*].app[*].thinkTime = (exponential(10ms))  # makes each session longer
*.client[*].app[*].idleInterval = exponential(100ms) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------

[Config Scenario3-Type1-Short-Sessions-No-Q-drops-reliable]
description = "Similar to sc1 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27)))#each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------------

[Config Scenario3-Type1-Short-Sessions-No-Q-drops-not-reliable]
description = "Similar to sc1 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27)))#each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#-----------------------------------------
[Config Scenario3-Type1-Short-Sessions-No-Q-drops-not-reliable-RTOS]
description = "Similar to sc1 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(3,12))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = 401
*.client[*].app[*].RTOS = true

*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(400ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27)))#each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#-----------------------------------------
[Config Scenario3-Type2-Poisson-reliable-RTOS]
description = "Similar to sc1 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(3,12))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401
*.client[*].app[*].RTOS = true

*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(400ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(binomial(6,0.9)))#each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#-----------------------------------------
[Config Scenario3-Type2-Long-Sessions-No-Q-drops-reliable]
description = "Similar to sc1 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 100000000
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------

[Config Scenario3-Type2-Long-Sessions-No-Q-drops-not-reliable]
description = "Similar to sc1 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 100000000
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next



                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
#----------------------------------------------

[Config Scenario4-Type1-Short-Sessions-Q-drops-reliable]
description = "Similar to sc2 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
#----------------------------------------------

[Config Scenario4-Type1-Short-Sessions-Q-drops-not-reliable]
description = "Similar to sc2 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario4-Type2-Long-Sessions-Q-drops-reliable]
description = "Similar to sc2 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario4-Type2-Long-Sessions-Q-drops-reliable-1]
description = "Similar to sc2 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=1
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 40# int(uniform(2,8))*15
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                   
#-------------------------------------------------
[Config Scenario4-Type2-Long-Sessions-Q-drops-not-reliable]
description = "Similar to sc2 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------

[Config Scenario4-Type2-Long-Sessions-Q-drops-not-reliable-RTOS]
description = "Similar to sc2 but other clients also exist on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(3,9))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = 401

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(400ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[*].app[*].RTOS = true

**.server[*].vm[*].localPort = 401

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------

[Config Scenario3-Type2-Load-balancer-No-Q-drops-reliable]
description = "Similar to sc3 but there is load balancing between 4 Vms on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = int(uniform(401,404))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 1000000# int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario3-Type2-Load-balancer-No-Q-drops-not-reliable]
description = "Similar to sc3 but there is load balancing between 4 Vms on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = int(uniform(401,404))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 1000000# int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario3-Type2-Long-Sessions-No-Q-drops-not-reliable-RTOS]
description = "Similar to sc3 but there is load balancing between 4 Vms on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = int(uniform(401,405))  # 
*.client[*].app[*].RTOS = true
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 1000000# int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------

[Config Scenario4-Type2-Long-Sessions-Load-Balancer-Q-drops-reliable]
description = "Similar to sc3 but there is load balancing between 4 Vms on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = int(uniform(401,404))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario3-Type2-Long-Sessions-Load-Balancer-No-Q-drops-not-reliable]
description = "Similar to sc3 but there is load balancing between 4 Vms on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = int(uniform(401,404))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 1000000 #int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario4-Type2-Long-Sessions-Load_Balancer-Q-drops-not-reliable]
description = "Similar to sc3 but there is load balancing between 4 Vms on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(2,8))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[*].numApps = 10 # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = int(uniform(401,404))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario5-Type2-Long-Sessions-no-Q-drops-reliable]
description = "Similar to sc3 but with varying workload on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(11,17))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[1*].numApps = 10 # number of different applications on each workload generator
*.client[0].numApps = 10
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401#int(uniform(401,405))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
#int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[0].app[*].startTime = 1s
*.client[1*].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(18000s,19000s))
*.client[6].app[*].startTime = int(uniform(19000s,20000s))
*.client[7].app[*].startTime = int(uniform(20000s,22000s))
*.client[8].app[*].startTime = int(uniform(21000s,23000s))
*.client[9].app[*].startTime = int(uniform(25000s,26000s))
##########################################################
*.client[2].app[*].stopTime = int(uniform(8000s,9000s))
*.client[3].app[*].stopTime = int(uniform(9000s,10000s))
*.client[4].app[*].stopTime = int(uniform(9000s,10000s))
*.client[5].app[*].stopTime = int(uniform(28000s,29000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(32000s,36000s))
*.client[8].app[*].stopTime = int(uniform(34000s,36000s))
*.client[9].app[*].stopTime = int(uniform(34000s,36000s))

**.server[*].vm[0].localPort = 401
#**.server[*].vm[1].localPort = 402
#**.server[*].vm[2].localPort = 403
#**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario5-Type2-Long-Sessions-no-Q-drops-not-reliable]
description = "Similar to sc3 but with varying workload on the server"
#The incoming workload is exactly the same, just the server load is changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(11,17))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[1*].numApps = 10 # number of different applications on each workload generator
*.client[0].numApps = 10
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = 401 #int(uniform(401,405))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
#int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[0].app[*].startTime = 1s
*.client[1*].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(18000s,19000s))
*.client[6].app[*].startTime = int(uniform(19000s,20000s))
*.client[7].app[*].startTime = int(uniform(20000s,22000s))
*.client[8].app[*].startTime = int(uniform(21000s,23000s))
*.client[9].app[*].startTime = int(uniform(25000s,26000s))
##########################################################
*.client[2].app[*].stopTime = int(uniform(8000s,9000s))
*.client[3].app[*].stopTime = int(uniform(9000s,10000s))
*.client[4].app[*].stopTime = int(uniform(9000s,10000s))
*.client[5].app[*].stopTime = int(uniform(28000s,29000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(32000s,36000s))
*.client[8].app[*].stopTime = int(uniform(34000s,36000s))
*.client[9].app[*].stopTime = int(uniform(34000s,36000s))

**.server[*].vm[0].localPort = 401
#**.server[*].vm[1].localPort = 402
#**.server[*].vm[2].localPort = 403
#**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------

[Config Scenario6-Type2-Long-Sessions-Q-drops-reliable]
description = "Similar to sc4 but with varying workload on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(11,17))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[1*].numApps = 10 # number of different applications on each workload generator
*.client[0].numApps = 10
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401#int(uniform(401,405))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*15
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[0].app[*].startTime = 1s
*.client[1*].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(18000s,19000s))
*.client[6].app[*].startTime = int(uniform(19000s,20000s))
*.client[7].app[*].startTime = int(uniform(20000s,22000s))
*.client[8].app[*].startTime = int(uniform(21000s,23000s))
*.client[9].app[*].startTime = int(uniform(25000s,26000s))
##########################################################
*.client[2].app[*].stopTime = int(uniform(8000s,9000s))
*.client[3].app[*].stopTime = int(uniform(9000s,10000s))
*.client[4].app[*].stopTime = int(uniform(9000s,10000s))
*.client[5].app[*].stopTime = int(uniform(28000s,29000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(32000s,36000s))
*.client[8].app[*].stopTime = int(uniform(34000s,36000s))
*.client[9].app[*].stopTime = int(uniform(34000s,36000s))

**.server[*].vm[0].localPort = 401
#**.server[*].vm[1].localPort = 402
#**.server[*].vm[2].localPort = 403
#**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario6-Type2-Long-Sessions-Q-drops-reliable-Load-Balancing]
description = "Similar to sc4 but with varying workload on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(11,17))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[1*].numApps = 10 # number of different applications on each workload generator
*.client[0].numApps = 10
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = int(uniform(401,405))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*15
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[0].app[*].startTime = 1s
*.client[1*].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(18000s,19000s))
*.client[6].app[*].startTime = int(uniform(19000s,20000s))
*.client[7].app[*].startTime = int(uniform(20000s,22000s))
*.client[8].app[*].startTime = int(uniform(21000s,23000s))
*.client[9].app[*].startTime = int(uniform(25000s,26000s))
##########################################################
*.client[2].app[*].stopTime = int(uniform(8000s,9000s))
*.client[3].app[*].stopTime = int(uniform(9000s,10000s))
*.client[4].app[*].stopTime = int(uniform(9000s,10000s))
*.client[5].app[*].stopTime = int(uniform(28000s,29000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(32000s,36000s))
*.client[8].app[*].stopTime = int(uniform(34000s,36000s))
*.client[9].app[*].stopTime = int(uniform(34000s,36000s))

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario6-Type2-Long-Sessions-Q-drops-reliable-Load-Balancing-RTOS]
description = "Similar to sc4 but with varying workload on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(11,17))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[1*].numApps = 10 # number of different applications on each workload generator
*.client[0].numApps = 10
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].RTOS = true

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = int(uniform(401,405))  # 
*.server[*].vm[*].replyDelay= 0#int(uniform(30ms,50ms))#int(exponential(50ms)) # required computation time
#*.server[*].vm[*].
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms)) # scheduling overhead
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*15
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[0].app[*].startTime = 1s
*.client[1*].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(18000s,19000s))
*.client[6].app[*].startTime = int(uniform(19000s,20000s))
*.client[7].app[*].startTime = int(uniform(20000s,22000s))
*.client[8].app[*].startTime = int(uniform(21000s,23000s))
*.client[9].app[*].startTime = int(uniform(25000s,26000s))
##########################################################
*.client[2].app[*].stopTime = int(uniform(8000s,9000s))
*.client[3].app[*].stopTime = int(uniform(9000s,10000s))
*.client[4].app[*].stopTime = int(uniform(9000s,10000s))
*.client[5].app[*].stopTime = int(uniform(28000s,29000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(32000s,36000s))
*.client[8].app[*].stopTime = int(uniform(34000s,36000s))
*.client[9].app[*].stopTime = int(uniform(34000s,36000s))

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario6-Type1-Short-Sessions-Q-drops-reliable-Load-Balancing-RTOS]
description = "Similar to sc4 but with varying workload on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(11,17))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[1*].numApps = 10 # number of different applications on each workload generator
*.client[0].numApps = 10
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].RTOS = true

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = int(uniform(401,405))  # 
*.server[*].vm[*].replyDelay= 0#int(uniform(30ms,50ms))#int(exponential(50ms)) # required computation time
#*.server[*].vm[*].
*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms)) # scheduling overhead
*.server[*].OS_scheduler.Q[*].capacity = 20
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[0].app[*].startTime = 1s
*.client[1*].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(18000s,19000s))
*.client[6].app[*].startTime = int(uniform(19000s,20000s))
*.client[7].app[*].startTime = int(uniform(20000s,22000s))
*.client[8].app[*].startTime = int(uniform(21000s,23000s))
*.client[9].app[*].startTime = int(uniform(25000s,26000s))
##########################################################
*.client[2].app[*].stopTime = int(uniform(8000s,9000s))
*.client[3].app[*].stopTime = int(uniform(9000s,10000s))
*.client[4].app[*].stopTime = int(uniform(9000s,10000s))
*.client[5].app[*].stopTime = int(uniform(28000s,29000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(32000s,36000s))
*.client[8].app[*].stopTime = int(uniform(34000s,36000s))
*.client[9].app[*].stopTime = int(uniform(34000s,36000s))

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario6-Type2-Long-Sessions-Q-drops-not-reliable]
description = "Similar to sc4 but with varying workload on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(11,17))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[1*].numApps = 10 # number of different applications on each workload generator
*.client[0].numApps = 10
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = 401#int(uniform(401,405))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*15
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[0].app[*].startTime = 1s
*.client[1*].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(18000s,19000s))
*.client[6].app[*].startTime = int(uniform(19000s,20000s))
*.client[7].app[*].startTime = int(uniform(20000s,22000s))
*.client[8].app[*].startTime = int(uniform(21000s,23000s))
*.client[9].app[*].startTime = int(uniform(25000s,26000s))
##########################################################
*.client[2].app[*].stopTime = int(uniform(8000s,9000s))
*.client[3].app[*].stopTime = int(uniform(9000s,10000s))
*.client[4].app[*].stopTime = int(uniform(9000s,10000s))
*.client[5].app[*].stopTime = int(uniform(28000s,29000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(32000s,36000s))
*.client[8].app[*].stopTime = int(uniform(34000s,36000s))
*.client[9].app[*].stopTime = int(uniform(34000s,36000s))

**.server[*].vm[0].localPort = 401
#**.server[*].vm[1].localPort = 402
#**.server[*].vm[2].localPort = 403
#**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario5-Type1-Short-Sessions-no-Q-drops-reliable]
description = "Similar to sc3 but with varying workload on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(11,17))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[1*].numApps = 10 # number of different applications on each workload generator
*.client[0].numApps = 10
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401#int(uniform(401,405))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
#int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[0].app[*].startTime = 1s
*.client[1*].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(18000s,19000s))
*.client[6].app[*].startTime = int(uniform(19000s,20000s))
*.client[7].app[*].startTime = int(uniform(20000s,22000s))
*.client[8].app[*].startTime = int(uniform(21000s,23000s))
*.client[9].app[*].startTime = int(uniform(25000s,26000s))
##########################################################
*.client[2].app[*].stopTime = int(uniform(8000s,9000s))
*.client[3].app[*].stopTime = int(uniform(9000s,10000s))
*.client[4].app[*].stopTime = int(uniform(9000s,10000s))
*.client[5].app[*].stopTime = int(uniform(28000s,29000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(32000s,36000s))
*.client[8].app[*].stopTime = int(uniform(34000s,36000s))
*.client[9].app[*].stopTime = int(uniform(34000s,36000s))

**.server[*].vm[0].localPort = 401
#**.server[*].vm[1].localPort = 402
#**.server[*].vm[2].localPort = 403
#**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario5-Type1-Short-Sessions-no-Q-drops-reliable-Load-Balancing]
description = "Similar to sc3 but with varying workload on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(11,17))
*.numServers = 1
*.server[*].numVms = 10 # Number of VMs on each Server  
*.client[1*].numApps = 10 # number of different applications on each workload generator
*.client[0].numApps = 10
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = int(uniform(401,411))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
#int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[0].app[*].startTime = 1s
*.client[1*].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(18000s,19000s))
*.client[6].app[*].startTime = int(uniform(19000s,20000s))
*.client[7].app[*].startTime = int(uniform(20000s,22000s))
*.client[8].app[*].startTime = int(uniform(21000s,23000s))
*.client[9].app[*].startTime = int(uniform(25000s,26000s))
##########################################################
*.client[2].app[*].stopTime = int(uniform(8000s,9000s))
*.client[3].app[*].stopTime = int(uniform(9000s,10000s))
*.client[4].app[*].stopTime = int(uniform(9000s,10000s))
*.client[5].app[*].stopTime = int(uniform(28000s,29000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(32000s,36000s))
*.client[8].app[*].stopTime = int(uniform(34000s,36000s))
*.client[9].app[*].stopTime = int(uniform(34000s,36000s))

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404
**.server[*].vm[4].localPort = 405
**.server[*].vm[5].localPort = 406
**.server[*].vm[6].localPort = 407
**.server[*].vm[7].localPort = 408
**.server[*].vm[8].localPort = 409
**.server[*].vm[9].localPort = 410


*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario5-Type1-Short-Sessions-no-Q-drops-reliable-Load-Balancing-RTOS]
description = "Similar to sc3 but with varying workload on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(11,17))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[1*].numApps = 10 # number of different applications on each workload generator
*.client[0].numApps = 10
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = int(uniform(401,405))  # 
*.client[*].app[*].RTOS=true

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
#int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[0].app[*].startTime = 1s
*.client[1*].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(18000s,19000s))
*.client[6].app[*].startTime = int(uniform(19000s,20000s))
*.client[7].app[*].startTime = int(uniform(20000s,22000s))
*.client[8].app[*].startTime = int(uniform(21000s,23000s))
*.client[9].app[*].startTime = int(uniform(25000s,26000s))
##########################################################
*.client[2].app[*].stopTime = int(uniform(8000s,9000s))
*.client[3].app[*].stopTime = int(uniform(9000s,10000s))
*.client[4].app[*].stopTime = int(uniform(9000s,10000s))
*.client[5].app[*].stopTime = int(uniform(28000s,29000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(32000s,36000s))
*.client[8].app[*].stopTime = int(uniform(34000s,36000s))
*.client[9].app[*].stopTime = int(uniform(34000s,36000s))

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404
#**.server[*].vm[4].localPort = 405
#**.server[*].vm[5].localPort = 406
#**.server[*].vm[6].localPort = 407
#**.server[*].vm[7].localPort = 408
#**.server[*].vm[8].localPort = 409
#**.server[*].vm[9].localPort = 410


*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario5-Type1-Short-Sessions-no-Q-drops-not-reliable]
description = "Similar to sc3 but with varying workload on the server"
#The incoming workload is exactly the same, just the server load is changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(11,17))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[1*].numApps = 10 # number of different applications on each workload generator
*.client[0].numApps = 10
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = 401 #int(uniform(401,405))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
#int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[0].app[*].startTime = 1s
*.client[1*].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(18000s,19000s))
*.client[6].app[*].startTime = int(uniform(19000s,20000s))
*.client[7].app[*].startTime = int(uniform(20000s,22000s))
*.client[8].app[*].startTime = int(uniform(21000s,23000s))
*.client[9].app[*].startTime = int(uniform(25000s,26000s))
##########################################################
*.client[2].app[*].stopTime = int(uniform(8000s,9000s))
*.client[3].app[*].stopTime = int(uniform(9000s,10000s))
*.client[4].app[*].stopTime = int(uniform(9000s,10000s))
*.client[5].app[*].stopTime = int(uniform(28000s,29000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(32000s,36000s))
*.client[8].app[*].stopTime = int(uniform(34000s,36000s))
*.client[9].app[*].stopTime = int(uniform(34000s,36000s))

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------

[Config Scenario6-Type1-Short-Sessions-Q-drops-reliable]
description = "Similar to sc4 but with varying workload on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(11,17))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[1*].numApps = 10 # number of different applications on each workload generator
*.client[0].numApps = 10
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401#int(uniform(401,405))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[0].app[*].startTime = 1s
*.client[1*].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(18000s,19000s))
*.client[6].app[*].startTime = int(uniform(19000s,20000s))
*.client[7].app[*].startTime = int(uniform(20000s,22000s))
*.client[8].app[*].startTime = int(uniform(21000s,23000s))
*.client[9].app[*].startTime = int(uniform(25000s,26000s))
##########################################################
*.client[2].app[*].stopTime = int(uniform(8000s,9000s))
*.client[3].app[*].stopTime = int(uniform(9000s,10000s))
*.client[4].app[*].stopTime = int(uniform(9000s,10000s))
*.client[5].app[*].stopTime = int(uniform(28000s,29000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(32000s,36000s))
*.client[8].app[*].stopTime = int(uniform(34000s,36000s))
*.client[9].app[*].stopTime = int(uniform(34000s,36000s))

**.server[*].vm[0].localPort = 401
#**.server[*].vm[1].localPort = 402
#**.server[*].vm[2].localPort = 403
#**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario6-Type1-Short-Sessions-Q-drops-not-reliable]
description = "Similar to sc4 but with varying workload on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(11,17))
*.numServers = 1
*.server[*].numVms = 1 # Number of VMs on each Server  
*.client[1*].numApps = 10 # number of different applications on each workload generator
*.client[0].numApps = 10
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = 401#int(uniform(401,405))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*10
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[0].app[*].startTime = 1s
*.client[1*].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(18000s,19000s))
*.client[6].app[*].startTime = int(uniform(19000s,20000s))
*.client[7].app[*].startTime = int(uniform(20000s,22000s))
*.client[8].app[*].startTime = int(uniform(21000s,23000s))
*.client[9].app[*].startTime = int(uniform(25000s,26000s))
##########################################################
*.client[2].app[*].stopTime = int(uniform(8000s,9000s))
*.client[3].app[*].stopTime = int(uniform(9000s,10000s))
*.client[4].app[*].stopTime = int(uniform(9000s,10000s))
*.client[5].app[*].stopTime = int(uniform(28000s,29000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(32000s,36000s))
*.client[8].app[*].stopTime = int(uniform(34000s,36000s))
*.client[9].app[*].stopTime = int(uniform(34000s,36000s))

**.server[*].vm[0].localPort = 401
#**.server[*].vm[1].localPort = 402
#**.server[*].vm[2].localPort = 403
#**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (1+int(bernoulli(0.4))*int(binomial(5,0.27))) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config paper1-pretio-NO-Q-drops-not-reliable]
description = "Similar to sc1 but other clients also exist on the server"
#The incoming workload is Poisson, just the queue drops are changing
repeat=100
seed-set =  ${repetition}
*.numClients = int(uniform(3,12))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[*].numApps = int(uniform(10,15)) # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[*].app[*].connectPort = int(uniform(401,404))

*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.S[*].sleepTime = int(uniform(3,12))*int(exponential(100ms))
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (2+int(bernoulli(0.4))*int(binomial(5,0.27)))#each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#-----------------------------------------
[Config paper1-pretio-NO-Q-drops-reliable]
description = "Similar to sc1 but other clients also exist on the server"
#The incoming workload is Poisson, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(3,12))
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[*].numApps = int(uniform(10,15)) # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = int(uniform(401,404))

*.server[*].OS_scheduler.S[*].schedulerStatus = true
*.server[*].OS_scheduler.S[*].sleepTime = int(uniform(3,12))*int(exponential(100ms))
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (2+int(bernoulli(0.4))*int(binomial(5,0.27)))#each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#-----------------------------------------
[Config paper1-pretio-NO-Q-drops-not-reliable-fixed-vm-containers]
description = "Similar to sc1 but other clients also exist on the server"
#The incoming workload is Poisson, just the queue drops are changing
repeat=100
seed-set =  ${repetition}
*.numClients = 4
*.numServers = 1
*.server[*].numVms = 4 # Number of VMs on each Server  
*.client[*].numApps = 10#int(uniform(10,15)) # number of different applications on each workload generator
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system

*.client[*].app[*].reliableProtocol = false
*.client[0].app[*].connectPort = 401
*.client[1].app[*].connectPort = 402
*.client[2].app[*].connectPort = 403
*.client[3].app[*].connectPort = 404

*.server[*].OS_scheduler.S[*].schedulerStatus = false
*.server[*].OS_scheduler.S[*].sleepTime =0# int(uniform(3,12))*int(exponential(100ms))
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = 10000000
*.server[*].OS_scheduler.Q[*].fifo = true

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = (2+int(bernoulli(0.4))*int(binomial(5,0.27)))#each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#-----------------------------------------
[Config Paper3-Type2-Long-Sessions-Q-drops-reliable-dynamic-LB]
description = "Similar to sc4 but with varying workload on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(11,17))
*.numServers = 1
*.server[*].numVms =  10# Number of VMs on each Server  
*.client[1*].numApps = 10 # number of different applications on each workload generator
*.client[0].numApps = 10
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].dynamicScaling=true
*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = 401#int(uniform(401,405))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*15
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[0].app[*].startTime = 1s
*.client[1*].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(18000s,19000s))
*.client[6].app[*].startTime = int(uniform(19000s,20000s))
*.client[7].app[*].startTime = int(uniform(20000s,22000s))
*.client[8].app[*].startTime = int(uniform(21000s,23000s))
*.client[9].app[*].startTime = int(uniform(25000s,26000s))
##########################################################
*.client[2].app[*].stopTime = int(uniform(8000s,9000s))
*.client[3].app[*].stopTime = int(uniform(9000s,10000s))
*.client[4].app[*].stopTime = int(uniform(9000s,10000s))
*.client[5].app[*].stopTime = int(uniform(28000s,29000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(32000s,36000s))
*.client[8].app[*].stopTime = int(uniform(34000s,36000s))
*.client[9].app[*].stopTime = int(uniform(34000s,36000s))

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404
**.server[*].vm[4].localPort = 405
**.server[*].vm[5].localPort = 406
**.server[*].vm[6].localPort = 407
**.server[*].vm[7].localPort = 408
**.server[*].vm[8].localPort = 409
**.server[*].vm[9].localPort = 410

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
[Config Scenario6-Type2-Long-Sessions-Q-drops-reliable-dynamic-LB-RTOS]
description = "Similar to sc4 but with varying workload on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
*.numClients = int(uniform(11,17))
*.numServers = 1
*.server[*].numVms =  10# Number of VMs on each Server  
*.client[1*].numApps = 10 # number of different applications on each workload generator
*.client[0].numApps = 10
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].dynamicScaling=true
*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].RTOS=true
*.client[*].app[*].connectPort = 401#int(uniform(401,405))  # 

*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity = int(uniform(2,8))*15
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[0].app[*].startTime = 1s
*.client[1*].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(18000s,19000s))
*.client[6].app[*].startTime = int(uniform(19000s,20000s))
*.client[7].app[*].startTime = int(uniform(20000s,22000s))
*.client[8].app[*].startTime = int(uniform(21000s,23000s))
*.client[9].app[*].startTime = int(uniform(25000s,26000s))
##########################################################
*.client[2].app[*].stopTime = int(uniform(8000s,9000s))
*.client[3].app[*].stopTime = int(uniform(9000s,10000s))
*.client[4].app[*].stopTime = int(uniform(9000s,10000s))
*.client[5].app[*].stopTime = int(uniform(28000s,29000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(32000s,36000s))
*.client[8].app[*].stopTime = int(uniform(34000s,36000s))
*.client[9].app[*].stopTime = int(uniform(34000s,36000s))

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404
**.server[*].vm[4].localPort = 405
**.server[*].vm[5].localPort = 406
**.server[*].vm[6].localPort = 407
**.server[*].vm[7].localPort = 408
**.server[*].vm[8].localPort = 409
**.server[*].vm[9].localPort = 410

*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------

#-----------------------------------------
[Config Paper3-Type2-Long-Sessions-Q-drops-reliable-dynamic-LB-Bursty]
description = "Similar to sc4 but with varying workload on the server"
#The incoming workload is exactly the same, just the queue drops are changing
repeat=100
seed-set = ${repetition}
#*.tcp.tcpEphemeralPortRange = "1024..65535"

*.numClients = int(uniform(11,17))
*.numServers = 1
*.server[*].numVms =  4# Number of VMs on each Server  
*.client[1*].numApps = 10 # number of different applications on each workload generator
*.client[0].numApps = 100
*.client[*].app[*].connectAddress = "server[0]" # dedicated server to our software system
*.client[*].app[*].dynamicScaling=false
*.client[*].app[*].reliableProtocol = true
*.client[*].app[*].connectPort = int(uniform(401,405))  # 
#*.client[*].app[*].localPort=1000
#*.client[1*].app[*].connectPort = 402
#*.client[2].app[*].connectPort = 401 #int(uniform(401,403))
#*.client[3].app[*].connectPort = 401#int(uniform(401,403))  # 
#*.client[4].app[*].connectPort = 401#int(uniform(401,403))
#*.client[5].app[*].connectPort = 401#int(uniform(401,403))  # 
#*.client[6].app[*].connectPort = 401#int(uniform(401,403))
#*.client[7].app[*].connectPort = 401#int(uniform(401,403))  # 
#*.client[8].app[*].connectPort = 401#int(uniform(401,403))
#*.client[9].app[*].connectPort = 401#int(uniform(401,403))  # 


*.server[*].OS_scheduler.S[*].sleepTime = 0s
*.server[*].OS_scheduler.S[*].scheduleShare = 10s # there is scheduler between VMs 
*.server[*].OS_scheduler.S[*].serviceTime = int(exponential(300ms))
*.server[*].OS_scheduler.Q[*].capacity =  int(uniform(2,8))*15
*.server[*].OS_scheduler.Q[*].fifo = true
*.client[0].app[*].startTime = 1s
*.client[1*].app[*].startTime = int(uniform(500s,1000s))
*.client[2].app[*].startTime = int(uniform(2000s,3000s))
*.client[3].app[*].startTime = int(uniform(3500s,5000s))
*.client[4].app[*].startTime = int(uniform(3000s,5000s))
*.client[5].app[*].startTime = int(uniform(18000s,19000s))
*.client[6].app[*].startTime = int(uniform(19000s,20000s))
*.client[7].app[*].startTime = int(uniform(20000s,22000s))
*.client[8].app[*].startTime = int(uniform(21000s,23000s))
*.client[9].app[*].startTime = int(uniform(25000s,26000s))
##########################################################
*.client[2].app[*].stopTime = int(uniform(8000s,9000s))
*.client[3].app[*].stopTime = int(uniform(9000s,10000s))
*.client[4].app[*].stopTime = int(uniform(9000s,10000s))
*.client[5].app[*].stopTime = int(uniform(28000s,29000s))
*.client[6].app[*].stopTime = int(uniform(30000s,36000s))
*.client[7].app[*].stopTime = int(uniform(32000s,36000s))
*.client[8].app[*].stopTime = int(uniform(34000s,36000s))
*.client[9].app[*].stopTime = int(uniform(34000s,36000s))

**.server[*].vm[0].localPort = 401
**.server[*].vm[1].localPort = 402
**.server[*].vm[2].localPort = 403
**.server[*].vm[3].localPort = 404
#**.server[*].vm[4].localPort = 405
#**.server[*].vm[5].localPort = 406
#**.server[*].vm[6].localPort = 407
#**.server[*].vm[7].localPort = 408
#**.server[*].vm[8].localPort = 409
#**.server[*].vm[9].localPort = 410

*.client[0].app[*].startBurst = 1s
*.client[0].app[*].burstLen =300s
*.client[0].app[*].burstyTraffic=true


*.client[*].app[*].thinkTime = int(exponential(10ms))  # makes each session longer, this is after server responds
*.client[*].app[*].idleInterval = int(exponential(100ms)) # time between two sessions
*.client[*].app[*].numRequestsPerSession = 1+int(binomial(6,0.9)) #each user session first makes an initial http request, then if the conditions for subsequent event met, the next
                                                                                       #req made, this is simulated using bernoulli. the remaining markovian sequence of events simulated using binomial
#----------------------------------------------
